{"/docs/":{"data":{"":"","-how-to-run#âš™ï¸ How to Run":"Microservices Architecture â€” Docker Compose Setup! Welcome to the documentation for the microservices architecture development environment! This repository includes a docker-compose.yml file designed to spin up all necessary services for local development.\nğŸš€ Overview This Docker Compose setup orchestrates multiple services that together form a microservices-based application ecosystem. It is only intended for development purposes and includes:\nNATS \u0026 NATS UI: Messaging system with JetStream enabled for event streaming and an admin UI for monitoring. MongoDB: Document-oriented NoSQL database for data storage. MinIO: High-performance, S3-compatible object storage. Various Application Services: Gateway: API gateway routing requests. User Service: Manages user data and authentication. Angebot Service: Business-specific service for offers management. Media Service: Handles media file uploads and processing. Frontend \u0026 NGINX: Web frontend served through NGINX with HTTPS support. ğŸ“¦ Services Included Service Description Ports nats Messaging server with JetStream enabled 4222, 8222 nats-ui NATS monitoring UI 31311 mongo MongoDB database 27017 minio Object storage (S3 compatible) 9000 (API), 9001 (Console) gateway API Gateway 8081 user-service User management 8082 angebot-service Offers management 8084 media-service Media handling 8083 frontend Web frontend 8080 nginx Reverse proxy \u0026 HTTPS termination 80, 443 âš™ï¸ How to Run Make sure you have Docker and Docker Compose installed.\nClone the repository:\ngit clone https://github.com/Konzepte-moderner-Softwareentwicklung/Backend.git cd Backend ","-overview#ğŸš€ Overview":"","-services-included#ğŸ“¦ Services Included":"","microservices-architecture--docker-compose-setup#Microservices Architecture â€” Docker Compose Setup!":""},"title":"Docs"},"/docs/chat-service/":{"data":{"-abhÃ¤ngigkeiten#ğŸ§© AbhÃ¤ngigkeiten":"","-api-endpunkte#ğŸ“š API-Endpunkte":"","-authentifizierung#ğŸ” Authentifizierung":"","-chatcontroller--dokumentation#ğŸ“¦ ChatController â€“ Dokumentation":"","-erweiterbarkeit#ğŸ”„ Erweiterbarkeit":"","-fehlerbehandlung#ğŸ§ª Fehlerbehandlung":"","-funktionsweise-im-detail#âš™ï¸ Funktionsweise im Detail":"","-lizenz--kontakt#ğŸ“„ Lizenz \u0026amp; Kontakt":" classDiagram\rdirection TB\rclass ChatController {\r- service: Service\r- AuthMiddleware: AuthMiddleware\r+HandleGetChats(w http.ResponseWriter, r *http.Request)\r+CreateChat(w http.ResponseWriter, r *http.Request)\r+HandleGetChat(w http.ResponseWriter, r *http.Request)\r+HandleSendMessage(w http.ResponseWriter, r *http.Request)\r+setupRoutes()\r}\rclass Service {\r+GetChats(userId uuid.UUID) []Chat\r+CreateChat(userIds ...uuid.UUID) uuid.UUID\r+GetChat(chatId, userId uuid.UUID) []Message\r+SendMessage(userId, chatId uuid.UUID, content string) error\r}\rclass AuthMiddleware {\r+EnsureJWT(handler http.HandlerFunc) http.HandlerFunc\r}\rclass Server {\r+WithHandlerFunc(path string, handler http.HandlerFunc, method string)\r+Error(w http.ResponseWriter, message string, statusCode int)\r+GetLogger() Logger\r}\rclass CreateChatRequest {\r+UserIds: []uuid.UUID\r}\rclass SendMessageRequest {\r+Content: string\r}\rclass ErrorResponse {\r+Message: string\r}\rChatController --\u003e Service\rChatController --\u003e AuthMiddleware\rChatController --\u003e Server\rService --\u003e Repo\rRepo \u003c|.. Chat\rRepo \u003c|.. Message\rclass Chat {\r\u003c\u003cdata\u003e\u003e\r}\rclass Message {\r\u003c\u003cdata\u003e\u003e\r}\rclass Repo {\r\u003c\u003cinterface\u003e\u003e\r} ğŸ“¦ ChatController â€“ DokumentationğŸ§­ Ãœbersicht Der ChatController ist ein HTTP-Controller fÃ¼r den Chat-Service der Anwendung. Er stellt verschiedene REST-Endpoints zur VerfÃ¼gung, um Chats zu erstellen, abzurufen und Nachrichten zu versenden. Der Controller verwendet JWT-Authentifizierung und basiert auf Gorilla Mux fÃ¼r das Routing.\nğŸ§© AbhÃ¤ngigkeiten github.com/google/uuid â€“ zur Arbeit mit UUIDs.\ngithub.com/gorilla/mux â€“ HTTP-Router.\nBenutzerdefinierte Module:\nservice â€“ enthÃ¤lt die GeschÃ¤ftslogik fÃ¼r Chats. repo â€“ Schnittstelle zur Datenbank. auth â€“ JWT-Authentifizierung. server â€“ generische Server-Initialisierung und Hilfsmethoden. ğŸ” Authentifizierung Alle Endpunkte sind durch ein JWT geschÃ¼tzt. Der Authentifizierungs-Middleware EnsureJWT() Ã¼berprÃ¼ft den Token und stellt sicher, dass der Request gÃ¼ltig ist. Die UserId wird aus dem HTTP-Header UserIdHeader gelesen, der durch die Middleware gesetzt wird.\nğŸ“š API-Endpunkte GET /chat Beschreibung: Gibt alle Chats des authentifizierten Nutzers zurÃ¼ck. Header: Authorization: Bearer \u003cJWT\u003e Antwort: JSON-Liste von repo.Chat Objekten.\nPOST /chat Beschreibung: Erstellt einen neuen Chat mit den angegebenen Benutzer-IDs (inklusive sich selbst). Body:\n{ \"userIds\": [\"\u003cuuid1\u003e\", \"\u003cuuid2\u003e\", ...] } Antwort: ID des neu erstellten Chats als JSON-String.\nGET /chat/{chatId} Beschreibung: Gibt alle Nachrichten fÃ¼r einen bestimmten Chat zurÃ¼ck. Path-Parameter: chatId (UUID) Antwort: JSON-Liste von repo.Message Objekten.\nPOST /chat/{chatId}/messages Beschreibung: Sendet eine Nachricht in einen bestimmten Chat. Path-Parameter: chatId (UUID) Body:\n{ \"content\": \"Hallo Welt!\" } Antwort: HTTP 201 Created, keine Body-Antwort.\nâš™ï¸ Funktionsweise im Detail Initialisierung: Die Funktion New() erstellt eine neue ChatController-Instanz, registriert alle Routen und initialisiert den Service. Routing: Wird durch setupRoutes() konfiguriert. Fehlerbehandlung: Einheitlich Ã¼ber die Methode Error(w, message, code) aus der eingebetteten Server-Struktur. Logging: Der Controller nutzt GetLogger().Debug() zur Protokollierung von Nachrichten. ğŸ§ª Fehlerbehandlung Die API gibt im Fehlerfall strukturierte JSON-Objekte vom Typ ErrorResponse zurÃ¼ck:\n{ \"message\": \"Fehlermeldung\" } HTTP-Statuscodes:\n400 Bad Request: UngÃ¼ltige UUIDs, fehlerhaftes JSON etc. 500 Internal Server Error: Fehler aus der GeschÃ¤ftslogik oder Datenbank. ğŸ”„ Erweiterbarkeit Der Controller ist modular aufgebaut:\nNeue Endpunkte kÃ¶nnen leicht durch weitere Methoden und WithHandlerFunc-Registrierungen ergÃ¤nzt werden. Service-Schicht kapselt die GeschÃ¤ftslogik und ist leicht austauschbar/testbar. Durch Middleware flexibel erweiterbar (z.â€¯B. fÃ¼r Rate-Limiting, Logging, etc.). ğŸ§¼ TODOs \u0026 Verbesserungspotenzial Zentrale Validierung fÃ¼r JSON-Requests und UUIDs. RÃ¼ckgabe von IDs/Objekten als strukturierte Objekte, nicht als rohe Strings. Einheitliches Logging (z.â€¯B. mit TraceID). Verbesserte Fehlerdifferenzierung (z.â€¯B. 403 wenn User nicht Teil des Chats ist). ğŸ“„ Lizenz \u0026 Kontakt Dieses Projekt ist Teil der Lehrveranstaltung Konzepte moderner Softwareentwicklung und dient als Lernbeispiel fÃ¼r REST-API-Design mit Go.","-todos--verbesserungspotenzial#ğŸ§¼ TODOs \u0026amp; Verbesserungspotenzial":"","-Ã¼bersicht#ğŸ§­ Ãœbersicht":""},"title":"Chat Service"},"/docs/gateway/":{"data":{"beispiel-client-code-javascript#Beispiel Client-Code (JavaScript)":"Gateway Service - DokumentationDer Gateway-Service ist ein zentraler HTTP-Proxy, der eingehende Anfragen basierend auf dem URL-Pfad an die jeweils zustÃ¤ndigen Microservices weiterleitet.\nZweck Zentrale Anlaufstelle fÃ¼r Clients Weiterleitung von HTTP-Anfragen an Microservices Einfaches Routing basierend auf URL-PrÃ¤fixen Einheitliche Schnittstelle fÃ¼r mehrere Backend-Services Routing-Regeln URL-Pfad-PrÃ¤fix Zielservice Beschreibung api/user/* User-Service (z.B. http://userservice:8080) Benutzerverwaltung api/angebot/* Angebot-Service (z.B. http://angebotservice:8080) Angebotsverwaltung api/media/* Media-Service (z.B. http://mediaservice:8080) Medienverwaltung / (andere) Frontend oder 404-Fehler Standardseite oder Fehlerseite Nutzung als Client Clients senden alle Anfragen an das Gateway (z.B. https://localhost/api). Das Gateway sorgt automatisch dafÃ¼r, dass die Anfragen beim richtigen Service landen.\nBeispiel-Endpunkte (Ã¼ber Gateway) HTTP Methode Pfad Zweck GET api/user/ Liste aller Benutzer abrufen POST api/user/ Neuen Benutzer anlegen PUT api/user/{id} Benutzer aktualisieren DELETE api/user/{id} Benutzer lÃ¶schen GET api/angebot/ Angebote abrufen GET api/media/{id} Mediendatei abrufen GET / Frontend oder Startseite Vorteile Vereinfachte Client-Integration: Ein einziger Endpunkt fÃ¼r alle Services Flexibles Routing: Einfaches HinzufÃ¼gen neuer Services und Pfade Zentrale Sicherheitskontrolle: Authentifizierung, Logging oder Rate-Limiting kÃ¶nnen hier zentral implementiert werden Entkopplung der Clients von den Backend-Services Beispiel Client-Code (JavaScript) const BASE_URL = \"https://localhost\"; // Benutzerliste abrufen async function fetchUsers() { const response = await fetch(`${BASE_URL}/users/`); if (!response.ok) throw new Error(\"Fehler beim Abrufen der Benutzer\"); return response.json(); } // Benutzer erstellen async function createUser(userData) { const response = await fetch(`${BASE_URL}/users/`, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(userData), }); if (!response.ok) throw new Error(\"Fehler beim Erstellen des Benutzers\"); return response.json(); } // Angebot abrufen async function fetchAngebote() { const response = await fetch(`${BASE_URL}/angebote/`); if (!response.ok) throw new Error(\"Fehler beim Abrufen der Angebote\"); return response.json(); } ","beispiel-endpunkte-Ã¼ber-gateway#Beispiel-Endpunkte (Ã¼ber Gateway)":"","gateway-service---dokumentation#Gateway Service - Dokumentation":"","nutzung-als-client#Nutzung als Client":"","routing-regeln#Routing-Regeln":"","vorteile#Vorteile":"","zweck#Zweck":""},"title":"Gateway"},"/docs/login/":{"data":{"":"","-klassische-anmeldung-e-mail--passwort#ğŸ“¥ Klassische Anmeldung: E-Mail \u0026amp; Passwort":"","-logout#ğŸ“¤ Logout":"","-passwortlos-anmelden-mit-passkey-webauthn#ğŸ” Passwortlos anmelden mit Passkey (WebAuthn)":"","-sicherheitshinweise#ğŸ”’ Sicherheitshinweise":"","-token-nutzung#ğŸ§ª Token-Nutzung":"","-websocket-verbindung#ğŸŒ WebSocket-Verbindung":"","-weitere-methoden#ğŸ“š Weitere Methoden":"Dieser Service ermÃ¶glicht es Benutzern, sich Ã¼ber E-Mail/Passwort oder passwortlos via WebAuthn (Passkey) anzumelden. Die Authentifizierung erzeugt ein Token, das fÃ¼r nachfolgende geschÃ¼tzte Anfragen benÃ¶tigt wird.\nğŸ“¥ Klassische Anmeldung: E-Mail \u0026 Passwort ğŸ”§ Methode await client.login(email, password); ğŸ§¾ Beschreibung Authentifiziert einen Benutzer mit E-Mail und Passwort. Beim Erfolg wird automatisch ein Authentifizierungstoken gespeichert und eine WebSocket-Verbindung geÃ¶ffnet.\nğŸ“Œ Parameter Name Typ Beschreibung email string Benutzer-E-Mail password string Benutzerpasswort âœ… Beispiel await client.login(\"benutzer@example.com\", \"meinPasswort123\"); âš ï¸ Fehlerbehandlung Falls die Anmeldung fehlschlÃ¤gt, wird eine aussagekrÃ¤ftige Fehlermeldung ausgelÃ¶st.\nğŸ” Passwortlos anmelden mit Passkey (WebAuthn) ğŸ”§ Methode await client.loginPasskey(email); ğŸ§¾ Beschreibung FÃ¼hrt eine passwortlose Anmeldung per Passkey (z.â€¯B. FaceID, TouchID, FIDO2-SicherheitsschlÃ¼ssel) durch. Diese Methode nutzt den WebAuthn-Standard zur sicheren Authentifizierung.\nğŸ“Œ Parameter Name Typ Beschreibung email string Die registrierte Benutzer-E-Mail âœ… Beispiel await client.loginPasskey(\"benutzer@example.com\"); ğŸ”„ Ablauf Holt Anmeldeoptionen vom Server (/api/user/webauthn/login/options). FÃ¼hrt WebAuthn-Authentifizierung durch. Sendet Authentifizierungsdaten an den Server zur Verifikation (/api/user/webauthn/login). Speichert Token und verbindet WebSocket. âš ï¸ Fehlerbehandlung UngÃ¼ltige E-Mail: Es wird eine Exception geworfen. Abbruch oder Verweigerung der WebAuthn-Anfrage durch den Benutzer fÃ¼hrt zu einem Fehler. ğŸŒ WebSocket-Verbindung Nach erfolgreichem Login (egal ob klassisch oder per Passkey) wird eine WebSocket-Verbindung automatisch aufgebaut:\nclient.connectWebSocket(); Dies ermÃ¶glicht z.â€¯B. serverseitige Push-Nachrichten in Echtzeit.\nğŸ§ª Token-Nutzung Das erhaltene Token wird in client.token gespeichert und automatisch in geschÃ¼tzten API-Requests (z.â€¯B. Angebotserstellung) verwendet.\nğŸ“¤ Logout ğŸ”§ Methode await client.logout(); Beschreibung Setzt das Token zurÃ¼ck. Trennt die WebSocket-Verbindung. ğŸ”’ Sicherheitshinweise Alle Passkey-bezogenen Anfragen verwenden credentials: \"include\" und CORS-Modus. Die Anmeldedaten werden nicht im Klartext Ã¼bertragen. Die WebAuthn-Authentifizierung erfolgt vollstÃ¤ndig im Browser. ğŸ“š Weitere Methoden FÃ¼r Registrierung mit Passkey siehe:\nawait client.registerPasskey(); FÃ¼r Benutzer-Management siehe Methoden wie getUsers(), createUser(), etc."},"title":"Login"},"/docs/media-service/":{"data":{"basis-url#Basis-URL":"","beispiel-curl-download-bild#Beispiel Curl Download (Bild)":"Media Service - DokumentationDer Media Service stellt Endpunkte zum Upload und Download von Bildern bereit und verwaltet einzelne sowie mehrere (komplexe) Bild-Links.\nBasis-URL /media\nEndpunkte 1. GET /media/image Beschreibung: Test- oder Index-Endpunkt, gibt â€œHello Worldâ€ zurÃ¼ck. Request Body: Kein Response: Plain Text \"Hello World\" Status Codes: 200 OK 2. POST /media/image Beschreibung: Upload eines einzelnen Bildes.\nRequest Header:\nContent-Type: Muss den Medientyp des Bildes angeben (z.B. image/jpeg). UserId: ID des hochladenden Benutzers (wird als Header erwartet). Request Body: BinÃ¤rdaten des Bildes.\nResponse Body (JSON):\n{ \"name\": \"string\", \"success\": true } Status Codes:\n200 OK bei Erfolg 400 Bad Request, wenn Content-Type oder UserId fehlt 500 Internal Server Error bei Upload-Fehlern 3. GET /media/image/{id} Beschreibung: Download eines Bildes nach Bild-ID (Name).\nURL-Parameter:\nid (string): Bildname/ID. Response:\nBilddaten mit Header Content-Type: image/jpeg Status Codes:\n200 OK bei Erfolg 400 Bad Request, wenn id fehlt 500 Internal Server Error bei Fehlern 4. GET /media/multi/{id} Beschreibung: Gibt eine Liste von Bild-URLs (compound links) zurÃ¼ck, die zu einer zusammengesetzten EntitÃ¤t gehÃ¶ren.\nURL-Parameter:\nid (UUID): ID der zusammengesetzten EntitÃ¤t. Response Body (JSON): Array von URLs, z.B.\n[ \"/media/image/abc123\", \"/media/image/def456\" ] Status Codes:\n200 OK bei Erfolg 400 Bad Request, wenn id fehlt oder ungÃ¼ltig ist 500 Internal Server Error bei Fehlern 5. POST /media/multi/{id} Beschreibung: Upload eines Bildes zu einer zusammengesetzten EntitÃ¤t.\nURL-Parameter:\nid (string): ID der zusammengesetzten EntitÃ¤t. Request Header:\nContent-Type: Medientyp des Bildes UserId: ID des Benutzers (muss gesetzt sein) Request Body: BinÃ¤rdaten des Bildes\nResponse: Kein Body, nur Status-Code\nStatus Codes:\n200 OK bei Erfolg 400 Bad Request bei fehlenden Headern oder Parametern 500 Internal Server Error bei Upload-Fehlern Header Header Bedeutung Erforderlich? UserId ID des Nutzers, der hochlÃ¤dt Ja bei Uploads Fehlerhandling 400 Bad Request bei ungÃ¼ltigen oder fehlenden Parametern oder Headern. 500 Internal Server Error bei internen Fehlern. Beispiel Curl Upload (einzelnes Bild) curl -X POST https://localhost/api/media/image \\ -H \"Content-Type: image/jpeg\" \\ -H \"UserId: 1234\" \\ --data-binary \"@pfad/zum/bild.jpg\" Beispiel Curl Download (Bild) curl https://localhost/media/image/abc123 \u003e downloaded.jpg ","beispiel-curl-upload-einzelnes-bild#Beispiel Curl Upload (einzelnes Bild)":"","endpunkte#Endpunkte":"","fehlerhandling#Fehlerhandling":"","header#Header":"","media-service---dokumentation#Media Service - Dokumentation":""},"title":"Media Service"},"/docs/offer-service/":{"data":{"":"","-api-endpunkte#ğŸŒ API-Endpunkte":"","-authentifizierung#ğŸ” Authentifizierung":"","-builder-klassen#ğŸ§± Builder-Klassen":"","-fehlerbehandlung#âš ï¸ Fehlerbehandlung":"","-installation#ğŸ› ï¸ Installation":"","-verwendung#ğŸš€ Verwendung":"","-websocket-integration-optional#ğŸ’¬ WebSocket Integration (optional)":"Dieser Service ermÃ¶glicht das Erstellen, Abrufen und Filtern von Angeboten Ã¼ber eine einfache REST-API. Er unterstÃ¼tzt strukturierte Angebotsobjekte mithilfe von Builder-Pattern-Klassen und basiert auf einer tokenbasierten Authentifizierung.\nğŸ› ï¸ Installation Binde die Client, OfferBuilder, SpaceBuilder, ItemBuilder, etc. Klassen in deinem Frontend ein.\nStelle sicher, dass ein Backend mit folgenden Routen verfÃ¼gbar ist:\nPOST /api/angebot GET /api/angebot/:id POST /api/angebot/filter ğŸš€ Verwendung âœ… Angebot erstellen const client = new Client(); await client.login(\"user@example.com\", \"password\"); const size = new SizeBuilder().setWidth(100).setHeight(50).setDepth(30); const item = new ItemBuilder().setSize(size).setWeight(15); const space = new SpaceBuilder().addItem(item).setSeats(2); const locationFrom = new LocationBuilder().setLatitude(52.52).setLongitude(13.405); const locationTo = new LocationBuilder().setLatitude(48.1351).setLongitude(11.582); const offer = new OfferBuilder() .setTitle(\"Transport fÃ¼r MÃ¶bel\") .setDescription(\"Ich kann dein Sofa mitnehmen.\") .setPrice(50) .setLocationFrom(locationFrom.build()) .setLocationTo(locationTo.build()) .setStartDateTime(new Date().toISOString()) .setEndDateTime(new Date(Date.now() + 3600000).toISOString()) .setCanTransport(space.build()) .build(); await client.createOffer(offer); ğŸ” Angebote filtern const filter = new FilterBuilder() .setNameStartsWith(\"Transport\") .setLocationFrom(locationFrom) .setLocationTo(locationTo) .build(); const results = await client.getOffersByFilter(filter); console.log(results); ğŸ“„ Angebot abrufen const offer = await client.getOfferById(\"angebot-id-123\"); console.log(offer); ğŸ§± Builder-Klassen Klasse Zweck OfferBuilder Erstellen eines vollstÃ¤ndigen Angebots SpaceBuilder Beschreibt den verfÃ¼gbaren Platz ItemBuilder Einzelnes zu transportierendes Objekt SizeBuilder Dimensionen eines Items LocationBuilder Geografische Koordinaten FilterBuilder Filterkriterien fÃ¼r Angebotssuche Jede build()-Methode validiert automatisch alle Pflichtfelder und wirft bei Fehlern eine aussagekrÃ¤ftige Exception.\nğŸŒ API-Endpunkte Methode Pfad Beschreibung POST /api/angebot Erstellt ein neues Angebot GET /api/angebot/:id Holt ein Angebot per ID POST /api/angebot/filter Holt eine Liste gefilterter Angebote âš ï¸ Fehlerbehandlung Alle HTTP-Aufrufe werfen Exceptions bei FehlschlÃ¤gen. Fehlermeldungen werden als Error-Objekte mit Statuscodes und Text bereitgestellt:\ntry { await client.createOffer(myOffer); } catch (err) { console.error(\"Fehler beim Erstellen des Angebots:\", err.message); } ğŸ” Authentifizierung Der Nutzer muss vor dem Erstellen eines Angebots angemeldet sein. Ein gÃ¼ltiges Token wird intern vom Client verwaltet:\nawait client.login(\"email\", \"password\"); // Token wird automatisch gesetzt ğŸ’¬ WebSocket Integration (optional) Nach erfolgreicher Anmeldung wird automatisch ein WebSocket geÃ¶ffnet, z.B. fÃ¼r Echtzeitkommunikation:\nclient.registerOnMessage((msg) =\u003e { console.log(\"Neue Nachricht:\", msg); }); "},"title":"Angebot Service"},"/docs/user-service/":{"data":{"":"","-abhÃ¤ngigkeiten#ğŸ“¦ AbhÃ¤ngigkeiten":"","-beispiel-workflow#ğŸ“ Beispiel-Workflow":"Dieser Service ermÃ¶glicht das Anlegen und Abrufen von Benutzern Ã¼ber eine einfache API. Die Authentifizierung (Login, Token, WebAuthn) ist hierbei nicht erforderlich.\nğŸš€ Funktionen ğŸ”¹ Benutzer anlegen Verwende den bereitgestellten UserBuilder, um einen neuen Benutzer zu erstellen. Dies ist ohne vorherige Anmeldung mÃ¶glich.\nBeispiel: const client = new Client(); const user = new UserBuilder() .setFirstName(\"Max\") .setLastName(\"Mustermann\") .setEmail(\"max@example.com\") .setPassword(\"geheim123\") .setBirthDate(\"1990-01-01\") .setPhoneNumber(\"0123456789\") .setProfilePicture(\"https://example.com/profile.jpg\") .build(); await client.createUser(user); ğŸ” Hinweis: Das Passwort wird direkt im Klartext Ã¼bergeben. Stelle sicher, dass du HTTPS verwendest.\nğŸ”¹ Benutzer abrufen Alle Benutzer abrufen const users = await client.getUsers(); Benutzer nach E-Mail const user = await client.getUserByEmail(\"max@example.com\"); Benutzer nach ID const user = await client.getUserById(\"user_id_xyz\"); ğŸ“¦ AbhÃ¤ngigkeiten Die Kommunikation erfolgt Ã¼ber die fetch-API. JSON als Austauschformat. Keine Authentifizierung erforderlich (fÃ¼r die oben genannten Funktionen). ğŸ§° Tools Client: Hauptschnittstelle zur API. UserBuilder: Hilfsklasse zum einfachen und validierten Aufbau eines Benutzers. âš ï¸ Validierung Der UserBuilder erzwingt folgende Pflichtfelder:\nfirstName lastName email password Optional kÃ¶nnen angegeben werden:\nbirthDate phoneNumber profilePicture Falls Pflichtfelder fehlen, wird beim Aufruf von .build() ein Fehler geworfen.\nğŸ“ Beispiel-Workflow const client = new Client(); try { const user = new UserBuilder() .setFirstName(\"Anna\") .setLastName(\"Beispiel\") .setEmail(\"anna@example.com\") .setPassword(\"passwort123\") .build(); const response = await client.createUser(user); console.log(\"Benutzer erfolgreich erstellt:\", response); } catch (error) { console.error(\"Fehler beim Erstellen des Benutzers:\", error); } ","-funktionen#ğŸš€ Funktionen":"","-tools#ğŸ§° Tools":"","-validierung#âš ï¸ Validierung":""},"title":"User Service"}}