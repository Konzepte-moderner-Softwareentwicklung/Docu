{"/Docu/docs/":{"data":{"":"","-how-to-run#‚öôÔ∏è How to Run":" Make sure you have Docker and Docker Compose installed.\nClone the repository:\ngit clone https://github.com/Konzepte-moderner-Softwareentwicklung/Backend.git cd Backend docker compose up --build ","-overview#üöÄ Overview":"This Docker Compose setup orchestrates multiple services that together form a microservices-based application ecosystem. It is only intended for development purposes and includes:\nNATS \u0026 NATS UI: Messaging system with JetStream enabled for event streaming and an admin UI for monitoring. MongoDB: Document-oriented NoSQL database for data storage. MinIO: High-performance, S3-compatible object storage. Various Application Services: Gateway: API gateway routing requests. User Service: Manages user data and authentication. Angebot Service: Business-specific service for offers management. Media Service: Handles media file uploads and processing. Frontend \u0026 NGINX: Web frontend served through NGINX with HTTPS support. ","-services-included#üì¶ Services Included":" Service Description Ports nats Messaging server with JetStream enabled 4222, 8222 nats-ui NATS monitoring UI 31311 mongo MongoDB database 27017 minio Object storage (S3 compatible) 9000 (API), 9001 (Console) gateway API Gateway 8081 user-service User management 8082 angebot-service Offers management 8084 media-service Media handling 8083 frontend Web frontend 8080 nginx Reverse proxy \u0026 HTTPS termination 80, 443 ","microservices-architecture--docker-compose-setup#Microservices Architecture ‚Äî Docker Compose Setup!":"Microservices Architecture ‚Äî Docker Compose Setup! Welcome to the documentation for the microservices architecture development environment! This repository includes a docker-compose.yml file designed to spin up all necessary services for local development."},"title":"Docs"},"/Docu/docs/chat-service/":{"data":{"-abh√§ngigkeiten#üß© Abh√§ngigkeiten":" github.com/google/uuid ‚Äì zur Arbeit mit UUIDs.\ngithub.com/gorilla/mux ‚Äì HTTP-Router.\nBenutzerdefinierte Module:\nservice ‚Äì enth√§lt die Gesch√§ftslogik f√ºr Chats. repo ‚Äì Schnittstelle zur Datenbank. auth ‚Äì JWT-Authentifizierung. server ‚Äì generische Server-Initialisierung und Hilfsmethoden. ","-api-endpunkte#üìö API-Endpunkte":"GET /chat Beschreibung: Gibt alle Chats des authentifizierten Nutzers zur√ºck. Header: Authorization: Bearer \u003cJWT\u003e Antwort: JSON-Liste von repo.Chat Objekten.\nPOST /chat Beschreibung: Erstellt einen neuen Chat mit den angegebenen Benutzer-IDs (inklusive sich selbst). Body:\n{ \"userIds\": [\"\u003cuuid1\u003e\", \"\u003cuuid2\u003e\", ...] } Antwort: ID des neu erstellten Chats als JSON-String.\nGET /chat/{chatId} Beschreibung: Gibt alle Nachrichten f√ºr einen bestimmten Chat zur√ºck. Path-Parameter: chatId (UUID) Antwort: JSON-Liste von repo.Message Objekten.\nPOST /chat/{chatId}/messages Beschreibung: Sendet eine Nachricht in einen bestimmten Chat. Path-Parameter: chatId (UUID) Body:\n{ \"content\": \"Hallo Welt!\" } Antwort: HTTP 201 Created, keine Body-Antwort.","-authentifizierung#üîê Authentifizierung":"Alle Endpunkte sind durch ein JWT gesch√ºtzt. Der Authentifizierungs-Middleware EnsureJWT() √ºberpr√ºft den Token und stellt sicher, dass der Request g√ºltig ist. Die UserId wird aus dem HTTP-Header UserIdHeader gelesen, der durch die Middleware gesetzt wird.","-chatcontroller--dokumentation#üì¶ ChatController ‚Äì Dokumentation":" classDiagram direction TB class ChatController { - service: Service - AuthMiddleware: AuthMiddleware +HandleGetChats(w http.ResponseWriter, r *http.Request) +CreateChat(w http.ResponseWriter, r *http.Request) +HandleGetChat(w http.ResponseWriter, r *http.Request) +HandleSendMessage(w http.ResponseWriter, r *http.Request) +setupRoutes() } class Service { +GetChats(userId uuid.UUID) []Chat +CreateChat(userIds ...uuid.UUID) uuid.UUID +GetChat(chatId, userId uuid.UUID) []Message +SendMessage(userId, chatId uuid.UUID, content string) error } class AuthMiddleware { +EnsureJWT(handler http.HandlerFunc) http.HandlerFunc } class Server { +WithHandlerFunc(path string, handler http.HandlerFunc, method string) +Error(w http.ResponseWriter, message string, statusCode int) +GetLogger() Logger } ChatController --\u003e Service ChatController --\u003e AuthMiddleware ChatController --\u003e Server Service --\u003e Repo class Repo { \u003c\u003cinterface\u003e\u003e } üì¶ ChatController ‚Äì Dokumentation","-erweiterbarkeit#üîÑ Erweiterbarkeit":"Der Controller ist modular aufgebaut:\nNeue Endpunkte k√∂nnen leicht durch weitere Methoden und WithHandlerFunc-Registrierungen erg√§nzt werden. Service-Schicht kapselt die Gesch√§ftslogik und ist leicht austauschbar/testbar. Durch Middleware flexibel erweiterbar (z.‚ÄØB. f√ºr Rate-Limiting, Logging, etc.). ","-fehlerbehandlung#üß™ Fehlerbehandlung":"Die API gibt im Fehlerfall strukturierte JSON-Objekte vom Typ ErrorResponse zur√ºck:\n{ \"message\": \"Fehlermeldung\" } HTTP-Statuscodes:\n400 Bad Request: Ung√ºltige UUIDs, fehlerhaftes JSON etc. 500 Internal Server Error: Fehler aus der Gesch√§ftslogik oder Datenbank. ","-funktionsweise-im-detail#‚öôÔ∏è Funktionsweise im Detail":" Initialisierung: Die Funktion New() erstellt eine neue ChatController-Instanz, registriert alle Routen und initialisiert den Service. Routing: Wird durch setupRoutes() konfiguriert. Fehlerbehandlung: Einheitlich √ºber die Methode Error(w, message, code) aus der eingebetteten Server-Struktur. Logging: Der Controller nutzt GetLogger().Debug() zur Protokollierung von Nachrichten. ","-√ºbersicht#üß≠ √úbersicht":"Der ChatController ist ein HTTP-Controller f√ºr den Chat-Service der Anwendung. Er stellt verschiedene REST-Endpoints zur Verf√ºgung, um Chats zu erstellen, abzurufen und Nachrichten zu versenden. Der Controller verwendet JWT-Authentifizierung und basiert auf Gorilla Mux f√ºr das Routing."},"title":"Chat Service"},"/Docu/docs/gateway/":{"data":{"beispiel-client-code-javascript#Beispiel Client-Code (JavaScript)":" const BASE_URL = \"https://localhost\"; // Benutzerliste abrufen async function fetchUsers() { const response = await fetch(`${BASE_URL}/users/`); if (!response.ok) throw new Error(\"Fehler beim Abrufen der Benutzer\"); return response.json(); } // Benutzer erstellen async function createUser(userData) { const response = await fetch(`${BASE_URL}/users/`, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(userData), }); if (!response.ok) throw new Error(\"Fehler beim Erstellen des Benutzers\"); return response.json(); } // Angebot abrufen async function fetchAngebote() { const response = await fetch(`${BASE_URL}/angebote/`); if (!response.ok) throw new Error(\"Fehler beim Abrufen der Angebote\"); return response.json(); } ","beispiel-endpunkte-√ºber-gateway#Beispiel-Endpunkte (√ºber Gateway)":" HTTP Methode Pfad Zweck GET api/user/ Liste aller Benutzer abrufen POST api/user/ Neuen Benutzer anlegen PUT api/user/{id} Benutzer aktualisieren DELETE api/user/{id} Benutzer l√∂schen GET api/angebot/ Angebote abrufen GET api/media/{id} Mediendatei abrufen GET / Frontend oder Startseite ","gateway-service---dokumentation#Gateway Service - Dokumentation":" classDiagram direction TB class Service { +*server.Server +*auth.AuthMiddleware +*jwt.Decoder +NR *natsreciver.Receiver +WSHandler(w http.ResponseWriter, r *http.Request) +HandleChatWS(w http.ResponseWriter, r *http.Request) +HandleTracking(w http.ResponseWriter, r *http.Request) +HealthCheck(w http.ResponseWriter, r *http.Request) +LogNats() +Close() error } class server.Server { +GetLogger() zerolog.Logger +WithHandlerFunc(path string, handler http.HandlerFunc, methods...) +Error(w http.ResponseWriter, message string, code int) } class auth.AuthMiddleware { +EnsureJWT(handler http.HandlerFunc) http.HandlerFunc } class jwt.Decoder { +DecodeUUID(token string) (uuid.UUID, error) } class natsreciver.Receiver { +Subscribe(subject string, handler func(*nats.Msg)) (Subscription, error) +Publish(subject string, data []byte) error +Close() error } class zerolog.Logger { +Info() +Debug() +Err(error) } class http.Request class http.ResponseWriter class websocket.Conn class TrackingRequest { +Location repoangebot.Location } Service --\u003e server.Server Service --\u003e auth.AuthMiddleware Service --\u003e jwt.Decoder Service --\u003e natsreciver.Receiver Service --\u003e websocket.Conn : Uses in WSHandler Service --\u003e zerolog.Logger : Uses for logging Service --\u003e TrackingRequest : Uses in HandleTracking Service --\u003e http.ResponseWriter : Handles HTTP Service --\u003e http.Request : Handles HTTP Gateway Service - DokumentationDer Gateway-Service ist ein zentraler HTTP-Proxy, der eingehende Anfragen basierend auf dem URL-Pfad an die jeweils zust√§ndigen Microservices weiterleitet.","nutzung-als-client#Nutzung als Client":"Clients senden alle Anfragen an das Gateway (z.B. https://localhost/api). Das Gateway sorgt automatisch daf√ºr, dass die Anfragen beim richtigen Service landen.","routing-regeln#Routing-Regeln":" URL-Pfad-Pr√§fix Zielservice Beschreibung api/user/* User-Service (z.B. http://userservice:8080) Benutzerverwaltung api/angebot/* Angebot-Service (z.B. http://angebotservice:8080) Angebotsverwaltung api/media/* Media-Service (z.B. http://mediaservice:8080) Medienverwaltung / (andere) Frontend oder 404-Fehler Standardseite oder Fehlerseite ","vorteile#Vorteile":" Vereinfachte Client-Integration: Ein einziger Endpunkt f√ºr alle Services Flexibles Routing: Einfaches Hinzuf√ºgen neuer Services und Pfade Zentrale Sicherheitskontrolle: Authentifizierung, Logging oder Rate-Limiting k√∂nnen hier zentral implementiert werden Entkopplung der Clients von den Backend-Services ","zweck#Zweck":" Zentrale Anlaufstelle f√ºr Clients Weiterleitung von HTTP-Anfragen an Microservices Einfaches Routing basierend auf URL-Pr√§fixen Einheitliche Schnittstelle f√ºr mehrere Backend-Services "},"title":"Gateway"},"/Docu/docs/login/":{"data":{"dokumentation-zum-login-im-usercontroller#Dokumentation zum Login im \u003ccode\u003eUserController\u003c/code\u003e":"Dokumentation zum Login im UserController","endpunkte-und-funktionen#Endpunkte und Funktionen":"1. Klassischer Login: /users/login (POST) Funktion: GetLoginToken\nBeschreibung: Authentifiziert einen Benutzer anhand von E-Mail und Passwort. Bei erfolgreicher Authentifizierung wird ein JWT-Token generiert, das 24 Stunden g√ºltig ist.\nRequest Body (JSON):\n{ \"email\": \"string\", \"password\": \"string\" } Ablauf:\nE-Mail und Passwort werden aus dem JSON-Request ausgelesen. Benutzer wird anhand der E-Mail gesucht. Passwort wird mit dem gespeicherten Hash verglichen (√ºber hasher.VerifyPassword). Bei Erfolg wird ein JWT-Token erzeugt (EncodeUUID) und als JSON zur√ºckgegeben. Bei Fehlern wird ein entsprechender HTTP-Statuscode mit Fehlermeldung zur√ºckgegeben. Antwort (bei Erfolg):\n{ \"token\": \"JWT-Token\" } Fehler:\n400: Fehler beim Lesen der Anfrage 401: Falsches Passwort 500: Nutzer nicht gefunden oder Fehler bei Token-Generierung 2. WebAuthn Login WebAuthn-Login erfolgt in zwei Schritten: Optionen abrufen und Login abschlie√üen.\na) Begin WebAuthn Login: /users/webauthn/login/options (GET) Funktion: beginLogin\nBeschreibung: Startet den WebAuthn-Login-Prozess, indem Login-Optionen generiert werden.\nQuery Parameter:\nemail: E-Mail-Adresse des Benutzers Ablauf:\nValidiert die E-Mail-Adresse. Benutzer wird anhand der E-Mail gesucht. Login-Optionen und Session-Daten werden erzeugt (service.webauth.BeginLogin). Session-Daten werden im Benutzerobjekt gespeichert. Login-Optionen werden als JSON zur√ºckgegeben. Antwort (bei Erfolg): JSON mit WebAuthn-CredentialAssertion.\nFehler:\n400: Ung√ºltige E-Mail-Adresse 404: Benutzer nicht gefunden 500: Interner Serverfehler b) Finish WebAuthn Login: /users/webauthn/login (POST) Funktion: finishLogin\nBeschreibung: Verifiziert die WebAuthn-Anmeldung und gibt bei Erfolg ein JWT-Token zur√ºck.\nQuery Parameter:\nemail: E-Mail-Adresse des Benutzers Ablauf:\nValidiert die E-Mail-Adresse. Benutzer wird anhand der E-Mail gesucht. WebAuthn-Login wird mit Session-Daten √ºberpr√ºft (service.webauth.FinishLogin). Bei Erfolg wird ein JWT-Token f√ºr 24 Stunden generiert und zur√ºckgegeben. Antwort (bei Erfolg):\n{ \"token\": \"JWT-Token\" } Fehler:\n400: Ung√ºltige E-Mail-Adresse 401: Authentifizierung fehlgeschlagen 404: Benutzer nicht gefunden 500: Interner Serverfehler ","wichtige-details#Wichtige Details":" JWT-Token: Ein JWT wird mit der Benutzer-ID als Payload erzeugt, g√ºltig f√ºr 24 Stunden.\nSession-Daten bei WebAuthn:\nBeginLogin und FinishLogin verwenden sessionData, die tempor√§r im User-Objekt gespeichert werden. Diese Session-Daten sind notwendig zur Validierung des WebAuthn-Ablaufs. Fehlerbehandlung: Alle Fehler f√ºhren zu einer aussagekr√§ftigen HTTP-Antwort mit Statuscode und Fehlermeldung.","√ºbersicht#√úbersicht":"Der UserController bietet mehrere Endpunkte zur Authentifizierung von Benutzern, sowohl √ºber klassische E-Mail/Passwort-Logins als auch √ºber WebAuthn (Passkey)-basierte Authentifizierung. Das Ziel ist es, den Benutzer sicher zu authentifizieren und bei Erfolg ein JWT-Token zur√ºckzugeben, das f√ºr 24 Stunden g√ºltig ist."},"title":"Login"},"/Docu/docs/media-service/":{"data":{"beispiel-request-upload-bild#Beispiel-Request Upload Bild":" curl -X POST \"http://localhost:8080/media/image\" \\ -H \"Authorization: Bearer \u003cjwt-token\u003e\" \\ -H \"UserId: \u003cuser-uuid\u003e\" \\ -H \"Content-Type: image/jpeg\" \\ --data-binary \"@meinbild.jpg\" ","endpunkte#Endpunkte":"GET /media/image Beschreibung: Health-Check Endpoint, gibt ‚ÄûHello World‚Äú zur√ºck Antwort: 200 OK, Text ‚ÄûHello World‚Äú POST /media/image Beschreibung: Upload eines einzelnen Bildes f√ºr den authentifizierten Benutzer\nHeaders:\nAuthorization (JWT Token, Pflicht) Content-Type (z.B. image/jpeg, Pflicht) UserId (User-ID im Header) Body: Bilddaten (rohe Bytes)\nAntwort:\n200 OK mit JSON { \"name\": \"\u003cBildname\u003e\", \"success\": true } Fehlercodes: 400 (Bad Request), 500 (Serverfehler) GET /media/image/{id} Beschreibung: Download eines Bildes anhand des Namens/IDs\nParameter:\nid (Pfadparameter, Bildname) Antwort:\n200 OK mit Bilddaten (image/jpeg) Fehlercodes: 400, 500 GET /media/multi/{id} Beschreibung: Gibt eine Liste von URLs zur√ºck, die zu mehreren Bildern (Compound Links) eines Nutzers geh√∂ren\nParameter:\nid (Pfadparameter, User UUID) Antwort:\n200 OK mit JSON-Array von Bild-URLs Fehlercodes: 400, 500 POST /media/multi/{id} Beschreibung: Upload eines Bildes, das mit Compound Links f√ºr einen bestimmten User/Offer verkn√ºpft wird\nHeaders:\nAuthorization (JWT Token) Content-Type (z.B. image/jpeg) UserId (User-ID im Header) Parameter:\nid (Pfadparameter, Compound Link ID) Body: Bilddaten (rohe Bytes)\nAntwort: 200 OK bei Erfolg\nFehlercodes: 400, 500","fehlerbehandlung#Fehlerbehandlung":"Der Controller gibt bei Fehlern aussagekr√§ftige HTTP-Statuscodes zur√ºck:\nStatuscode Bedeutung 400 Ung√ºltige Anfrage (z.B. fehlende Parameter, fehlerhafte UUID) 500 Interner Serverfehler (z.B. Probleme beim Zugriff auf Medienservice) ","implementierungsdetails#Implementierungsdetails":" Nutzt github.com/gorilla/mux f√ºr Routing. Setzt voraus, dass der User √ºber den UserIdHeader im HTTP Header identifiziert wird. Nutzt den MediaService (service.MediaService) f√ºr alle Business-Logik Operationen (Upload, Download, Verwaltung von Compound Links). Fehler werden als JSON mit { \"message\": \"Fehlermeldung\" } zur√ºckgegeben. Unterst√ºtzt Multipart-Bild-Uploads nicht (rohe Bytes im Request Body). ","mediaservice-controller#MediaService Controller":" classDiagram class MediaController { -mediaservice *MediaService -Server *Server +New(svc *MediaService) MediaController +setupRoutes() +handleIndex(w http.ResponseWriter, r *http.Request) +UploadPicture(w http.ResponseWriter, r *http.Request) +DownloadPicture(w http.ResponseWriter, r *http.Request) +GetCompoundLinks(w http.ResponseWriter, r *http.Request) +UploadToCompoundLinks(w http.ResponseWriter, r *http.Request) } class MediaService { +UploadPicture(ctx context.Context, user string, contentType string, img []byte) (string, error) +GetPicture(ctx context.Context, name string) ([]byte, error) +GetMultiPicture(ctx context.Context, user uuid.UUID) ([]string, error) +UploadPictureToMulti(ctx context.Context, user string, id string, contentType string, img []byte) error } class Server { +NewServer() *Server +WithHandlerFunc(path string, handler func(http.ResponseWriter, *http.Request), method string) +Error(w http.ResponseWriter, message string, code int) +GetLogger() Logger } class Logger { +Err(err error) } MediaController --\u003e MediaService : uses MediaController --\u003e Server : embeds Server --\u003e Logger : uses MediaService ControllerDer MediaService Controller stellt HTTP-Endpunkte bereit, um Bilder und Medieninhalte zu verwalten. Dies umfasst den Upload, Download und das Verwalten mehrerer Bild-Links f√ºr Benutzer oder Angebote.","√ºbersicht#√úbersicht":"Der Controller ist Teil des MediaService und bindet sich an die Business-Logik (service.MediaService) sowie den HTTP-Server (server.Server). Er bietet folgende Funktionalit√§ten:\nUpload einzelner Bilder (z.B. Profilbilder, Banner) Download einzelner Bilder Verwalten von ‚ÄúCompound Links‚Äù, d.h. mehreren Bildern, die einem Nutzer oder Objekt zugeordnet sind (z.B. mehrere Bilder zu einem Angebot) Healthcheck "},"title":"Media Service"},"/Docu/docs/offer-service/":{"data":{"-abh√§ngigkeiten#üìö Abh√§ngigkeiten":" Gorilla Mux ‚Äì Routing\nGoogle UUID\nNATS Go Client\nEigene Module:\nauth server ratingservice mediaservice/msclient angebotservice/service/repo_angebot ","-angebotservice#üì¶ Angebotservice":" classDiagram %% Controller class OfferController { - Server *server.Server - Client *msclient.Client - service service.Service - AuthMiddleware *auth.AuthMiddleware - Conn *nats.Conn + PayOffer() + OccupyOffer() + handleCreateOffer() + handleGetOffer() + handleGetOfferByFilter() + handlePostRating() } %% Services class service.Service { + CreateOffer(offer, imageURL) + GetOffer(uuid) + GetOffersByFilter(filter) + OccupieOffer(id, userId, space) + PayOffer(id, userId) } class repoangebot.Offer { - uuid ID - string Title - string Description - Location Location - float64 Price - float64 Size - Time AvailableFrom - uuid Creator } class repoangebot.Space { - float Width - float Height - float Depth } class repoangebot.Filter { - float MinPrice - float MaxPrice - float Latitude - float Longitude - float Radius } class ratingservice.Rating { - int Score - string Comment } %% Abh√§ngigkeiten \u0026 Beziehungen OfferController --\u003e service.Service OfferController --\u003e repoangebot.Offer OfferController --\u003e repoangebot.Space OfferController --\u003e repoangebot.Filter OfferController --\u003e ratingservice.Rating OfferController --\u003e msclient.Client OfferController --\u003e auth.AuthMiddleware OfferController --\u003e nats.Conn üì¶ AngebotserviceDer angebotservice stellt REST-HTTP-Endpunkte zur Verwaltung von Angeboten bereit. Dazu geh√∂ren das Erstellen, Abrufen, Buchen, Bezahlen und Bewerten von Angeboten. Die Authentifizierung erfolgt per JWT, und die Bewertung wird asynchron √ºber NATS verarbeitet.","-authentifizierung#üîê Authentifizierung":" JWT wird √ºber den HTTP-Header Authorization: Bearer \u003ctoken\u003e mitgesendet. Der Token muss die UserId enthalten, welche vom auth.AuthMiddleware ausgelesen und als Header UserId weitergereicht wird. ","-beispieldatenstrukturen#üßæ Beispieldatenstrukturen":"üéØ Angebotsstruktur (repoangebot.Offer) { \"title\": \"Tiefgaragenstellplatz\", \"description\": \"Mit direktem Zugang zum Aufzug.\", \"location\": { \"latitude\": 48.137, \"longitude\": 11.575 }, \"price\": 50, \"size\": 12, \"availableFrom\": \"2025-07-01\" } üì• Bewertung (ratingservice.Rating) { \"score\": 5, \"comment\": \"Super Angebot!\" } ","-features#üß∞ Features":" üîê Authentifizierte Angebots-Erstellung üîé Filterbare Angebotssuche üí¨ Bewertungen √ºber NATS Messaging üí≥ Angebotsbuchung \u0026 Bezahlung üñºÔ∏è Bild-URL-Generierung √ºber Medienservice ‚úÖ Swagger-kompatible API-Dokumentation ","-fehlerbehandlung#üêû Fehlerbehandlung":"Antworten im Fehlerfall sind konsistent aufgebaut:\n{ \"message\": \"Fehlerbeschreibung\" } Beispiele f√ºr Statuscodes:\n400 Bad Request ‚Äì z.‚ÄØB. bei fehlerhafter UUID 401 Unauthorized ‚Äì fehlende oder ung√ºltige JWT 500 Internal Server Error ‚Äì unerwartete Fehler ","-http-endpunkte#üîÅ HTTP-Endpunkte":" Methode Pfad Beschreibung Authentifizierung POST /angebot/filter Angebote nach Filter abrufen ‚ùå POST /angebot Neues Angebot erstellen ‚úÖ GET /angebot/{id} Angebot nach ID abrufen ‚ùå POST /angebot/{id}/occupy Angebot buchen ‚úÖ POST /angebot/{id}/pay Angebot bezahlen ‚úÖ POST /angebot/{id}/rating Angebot bewerten (via NATS) ‚úÖ ","-nats-messaging#üí¨ NATS Messaging":" Bewertungen werden nicht synchron in die Datenbank geschrieben. Stattdessen werden sie √ºber NATS ver√∂ffentlicht: c.Publish(\"rating.{userID}\", body) ","-quickstart#üöÄ Quickstart":"Voraussetzungen Go 1.20+ NATS Server (erreichbar √ºber Umgebungsvariable NATS_URL) Auth-Secret (f√ºr JWT-Middleware) Beispiel: Initialisierung svc := service.NewOfferService(repo, mediaClient) secret := []byte(\"dein_geheimes_jwt_secret\") controller := angebotservice.New(svc, secret) http.ListenAndServe(\":8080\", controller.Router) "},"title":"Angebot Service"},"/Docu/docs/rating-service/":{"data":{"endpunkt-get-ratingsuser#Endpunkt: GET /ratings/{user}":"Beschreibung Ruft alle Bewertungen f√ºr einen bestimmten Benutzer ab.\nPfadparameter Name Typ Pflicht Beschreibung user string ja UUID des Benutzers, f√ºr den die Bewertungen abgefragt werden Anfrage Methode: GET\nURL: /ratings/{user}\nHeader:\nAccept: application/json Antwort Erfolgsfall (200 OK): Ein JSON-Array mit den Bewertungen des angegebenen Benutzers. Beispiel:\n[ { \"id\": \"uuid\", \"userID\": \"uuid\", \"score\": 5, \"comment\": \"Great service!\" }, ... ] Fehlerf√§lle:\n400 Bad Request: Wenn die √ºbergebene Benutzer-ID keine g√ºltige UUID ist. Beispiel:\n{ \"message\": \"invalid UUID format\" } 500 Internal Server Error: Wenn ein unerwarteter Fehler beim Abrufen der Bewertungen auftritt. Beispiel:\n{ \"message\": \"database error\" } Hinweise Die Benutzer-ID muss im UUID-Format vorliegen. Die Methode GetRatings(userID uuid.UUID) wird verwendet, um die Bewertungen aus der Datenquelle zu holen. Die Response enth√§lt den Content-Type Header application/json. ","rating-service-api#Rating Service API":" classDiagram class Service { +setupRoutes() +HandleGetRatings(w http.ResponseWriter, r *http.Request) +GetRatings(userID uuid.UUID) ([]Rating, error) +Error(w http.ResponseWriter, message string, statusCode int) } class ErrorResponse { +Message string } class Rating { +ID uuid.UUID +UserID uuid.UUID +Score int +Comment string } Service \"1\" --\u003e \"*\" Rating : returns Rating Service APIDer Rating Service stellt eine HTTP-API zur Verf√ºgung, um Bewertungen (Ratings) f√ºr Benutzer abzurufen."},"title":"Rating Service"},"/Docu/docs/tracking-service/":{"data":{"abh√§ngigkeiten#Abh√§ngigkeiten":" MongoDB (Datenbank f√ºr Tracking-Daten). NATS (Messaging-System f√ºr Event-basierte Kommunikation). offerclient (Client zur Kommunikation mit dem Angebot-Service). zerolog (Logging-Framework). UUID (Identifikation von Benutzern). gateway.TrackingRequest (Datenmodell f√ºr Tracking-Daten). ","beispiel-f√ºr-tracking-daten-gatewaytrackingrequest#Beispiel f√ºr Tracking-Daten (gateway.TrackingRequest)":" { \"location\": { \"latitude\": 52.5200, \"longitude\": 13.4050 }, \"timestamp\": \"2025-06-27T12:00:00Z\" } ","fehlerbehandlung#Fehlerbehandlung":" Verbindungsfehler zu NATS oder MongoDB f√ºhren zu einem panic bei Initialisierung. Laufzeitfehler beim Verarbeiten von Nachrichten werden geloggt, der Service l√§uft jedoch weiter. Keine Angebote f√ºr einen User f√ºhren zu einer Info-Logmeldung. ","funktionsweise-start-methode#Funktionsweise (\u003ccode\u003eStart\u003c/code\u003e Methode)":" classDiagram class TrackingService { - queue *nats.Conn - logger zerolog.Logger - offerClient *offerclient.OfferClient - mongoClient TrackingRepo + NewTrackingService(natsURL string, offerURL string, mongoURL string) TrackingService + WithLogger(logger zerolog.Logger) TrackingService + Start() } class TrackingRepo { \u003c\u003cinterface\u003e\u003e + SaveTracking(tracking Tracking) error } class mongoTrackingRepo { - trackingCollection *mongo.Collection + SaveTracking(tracking Tracking) error } TrackingRepo \u003c|.. mongoTrackingRepo class Location { + Latitude float64 + Longitude float64 } TrackingService --\u003e TrackingRepo : uses Tracking Service Dokumentation√úberblick Der Tracking Service ist verantwortlich f√ºr das Erfassen, Speichern und Weiterleiten von Tracking-Daten der Benutzer. Er empf√§ngt Tracking-Informationen √ºber eine NATS-Messaging-Queue, speichert diese in einer MongoDB-Datenbank und ver√∂ffentlicht Tracking-Daten an verbundene Nutzer basierend auf verf√ºgbaren Angeboten.\nKomponenten 1. Repository (package repo) mongoTrackingRepo Verwaltet die MongoDB-Verbindung und die Sammlung (tracking). Verbindet sich mit der MongoDB √ºber die URI beim Erstellen (NewMongoTrackingRepo). Speichert Tracking-Daten mit SaveTracking(tracking Tracking) error in die MongoDB. Tracking (Struct) Repr√§sentiert ein Tracking-Dokument, das gespeichert wird.\nFelder:\nUserID (UUID): Die ID des Benutzers, zu dem das Tracking geh√∂rt. Tracking (gateway.TrackingRequest): Das eigentliche Tracking-Objekt, das Standort- und weitere Tracking-Daten enth√§lt. TrackingRepo (Interface) Definiert die Methode SaveTracking(Tracking) error, um Tracking-Daten zu speichern. 2. TrackingService (package trackingservice) Struktur queue (*nats.Conn): Verbindung zur NATS-Messaging-Queue. logger (zerolog.Logger): Logger f√ºr Ereignisse und Fehler. offerClient (*offerclient.OfferClient): Client zum Abrufen von Angeboten. mongoClient (repo.TrackingRepo): Repository zum Speichern der Tracking-Daten in MongoDB. Konstruktor func NewTrackingService(natsURL string, offerURL string, mongoURL string) *TrackingService Initialisiert alle notwendigen Komponenten (NATS-Verbindung, Logger, OfferClient, MongoDB Repository). Verbindet sich mit NATS, Offer-Service und MongoDB. Methoden WithLogger(logger zerolog.Logger) *TrackingService: Erm√∂glicht das Setzen eines benutzerdefinierten Loggers. Start(): Startet den Service und abonniert Tracking-Nachrichten auf dem NATS-Subject tracking.user.*. Funktionsweise (Start Methode) Abonnement auf NATS Topic tracking.user.*, wobei * die UserID ist.\nEmpfangene Nachrichten werden verarbeitet:\nExtrahieren der UserID aus dem Topic. Abrufen der relevanten Angebote f√ºr diesen User √ºber den offerClient. Wenn keine Angebote gefunden wurden, wird die Nachricht verworfen. Deserialisierung der Tracking-Daten (TrackingRequest). Speicherung der Tracking-Daten in MongoDB. Weiterleitung der Tracking-Daten an alle Benutzer, die im OccupiedSpace des Angebots enthalten sind. Fehler beim Parsen, Abrufen, Speichern oder Ver√∂ffentlichen werden geloggt.","komponenten#Komponenten":"","tracking-service-dokumentation#Tracking Service Dokumentation":"","√ºberblick#√úberblick":""},"title":"Tracking Service"},"/Docu/docs/user-service/":{"data":{"api-endpunkte-und-funktionalit√§ten#API-Endpunkte und Funktionalit√§ten":"Benutzer-Endpoints GET /self\nGibt die User-ID des aktuell authentifizierten Benutzers zur√ºck. Authentifizierung via JWT erforderlich. GET /users\nLiefert eine Liste aller Benutzer. GET /users/{id}\nLiefert Details eines Benutzers anhand der UUID (Passwort wird nicht zur√ºckgegeben). GET /users/email?email=...\nLiefert einen Benutzer anhand der E-Mail-Adresse. POST /users\nErstellt einen neuen Benutzer mit den √ºbergebenen JSON-Daten. PUT /users/{id}\nAktualisiert den Benutzer mit der angegebenen ID. Authentifizierung via JWT erforderlich. DELETE /users/{id}\nL√∂scht den Benutzer mit der angegebenen ID. Authentifizierung via JWT erforderlich. Authentifizierungsendpunkte POST /users/login\nAuthentifiziert einen Benutzer anhand von E-Mail und Passwort. Gibt bei Erfolg ein JWT zur√ºck, g√ºltig f√ºr 24 Stunden. WebAuthn Registrierung \u0026 Login\nGET /users/webauthn/register/options\nBeginnt die WebAuthn-Registrierung (liefert Registrierungsoptionen). Authentifizierung via JWT erforderlich. POST /users/webauthn/register\nSchlie√üt die WebAuthn-Registrierung ab. Authentifizierung via JWT erforderlich. GET /users/webauthn/login/options?email=...\nBeginnt die WebAuthn-Login-Prozedur (liefert Loginoptionen). POST /users/webauthn/login?email=...\nSchlie√üt den WebAuthn-Login ab und gibt ein JWT zur√ºck. Externe Bewertung GET /users/{id}/rating\nRuft Bewertungen des Benutzers vom externen Rating-Service ab. ","beispiel-f√ºr-eine-typische-benutzeranfrage#Beispiel f√ºr eine typische Benutzeranfrage":" Ein Client sendet eine POST-Anfrage an /users/login mit E-Mail und Passwort. Der Controller validiert die Eingaben, √ºberpr√ºft das Passwort und generiert ein JWT. Dieses JWT wird vom Client gespeichert und f√ºr zuk√ºnftige autorisierte Anfragen im Authorization-Header mitgeschickt. Bei Zugriff auf gesch√ºtzte Endpunkte wird das Token validiert, und die angeforderte Operation ausgef√ºhrt. ","dokumentation-zum-package-userservice#Dokumentation zum Package \u003ccode\u003euserservice\u003c/code\u003e":" classDiagram class UserController { +Server +AuthMiddleware +Encoder -service: UserService -ratingClient: RatingClient +GetSelfId(w http.ResponseWriter, r *http.Request) +HandleGetRating(w http.ResponseWriter, r *http.Request) +beginRegistration(w http.ResponseWriter, r *http.Request) +finishRegistration(w http.ResponseWriter, r *http.Request) +beginLogin(w http.ResponseWriter, r *http.Request) +finishLogin(w http.ResponseWriter, r *http.Request) +GetUsers(w http.ResponseWriter, r *http.Request) +GetUserByEmail(w http.ResponseWriter, r *http.Request) +CreateUser(w http.ResponseWriter, r *http.Request) +GetUser(w http.ResponseWriter, r *http.Request) +UpdateUser(w http.ResponseWriter, r *http.Request) +DeleteUser(w http.ResponseWriter, r *http.Request) +GetLoginToken(w http.ResponseWriter, r *http.Request) } class UserService { +GetUserByID(uuid.UUID) User +GetUsers() []User +CreateUser(User) error +UpdateUser(uuid.UUID, User) error +DeleteUser(uuid.UUID) error +repo: UserRepository +webauth: WebAuthService } class RatingClient { +GetRatingsByUserID(uuid.UUID) []Rating } class UserRepository { +GetUserByEmail(string) User +GetUserByID(uuid.UUID) User +UpdateUser(User) error } class WebAuthService { +BeginRegistration(User) (CredentialCreation, SessionData, error) +FinishRegistration(User, SessionData, *http.Request) (Credential, error) +BeginLogin(User) (CredentialAssertion, SessionData, error) +FinishLogin(User, SessionData, *http.Request) (bool, error) } class User { +ID: uuid.UUID +Email: string +Password: string +SessionData: SessionData +AddCredential(Credential) } UserController --\u003e UserService : uses UserController --\u003e RatingClient : uses UserService --\u003e UserRepository : uses UserService --\u003e WebAuthService : uses UserRepository ..\u003e User : manages WebAuthService ..\u003e User : operates on Dokumentation zum Package userservice","fehlerbehandlung#Fehlerbehandlung":"Fehler werden meist als JSON-Antwort mit einer ErrorResponse zur√ºckgegeben, die eine Fehlermeldung (Message) enth√§lt. Statuscodes wie 400 (Bad Request), 401 (Unauthorized), 404 (Not Found) und 500 (Internal Server Error) werden entsprechend gesetzt.","hauptkomponenten#Hauptkomponenten":"UserController UserController ist die zentrale Komponente, die HTTP-Anfragen entgegennimmt, verarbeitet und die Benutzerlogik koordiniert.\nFelder:\nServer ‚Äî HTTP-Server-Basis. AuthMiddleware ‚Äî Middleware zur JWT-Authentifizierung. Encoder ‚Äî JWT-Encoder zum Erstellen von Tokens. service ‚Äî Business-Logik-Service f√ºr Benutzeroperationen. ratingClient ‚Äî Client f√ºr den Zugriff auf externe Benutzerratings. Konstruktor:\nNew(svc *UserService, secret []byte) *UserController\nInitialisiert den Controller, l√§dt Umgebungsvariablen (z.B. RATING_SERVICE_URL), richtet Middleware ein und konfiguriert die API-Routen. ","middleware-und-cors#Middleware und CORS":"Der Controller setzt CORS-Header dynamisch basierend auf dem Origin der Anfrage. Zudem sch√ºtzt er kritische Endpunkte mit JWT-Authentifizierung mittels Middleware.","√ºberblick#√úberblick":"Das Package userservice implementiert einen HTTP-Controller zur Verwaltung von Benutzerkonten in einem Backend-System. Es bietet REST-API-Endpunkte f√ºr Benutzeroperationen wie Erstellen, Lesen, Aktualisieren, L√∂schen (CRUD), Authentifizierung via JWT und WebAuthn sowie Integration mit einem externen Bewertungssystem."},"title":"User Service"}}