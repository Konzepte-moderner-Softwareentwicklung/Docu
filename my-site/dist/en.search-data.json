{"/Docu/docs/":{"data":{"":"","-how-to-run#‚öôÔ∏è How to Run":"Microservices Architecture ‚Äî Docker Compose Setup! Welcome to the documentation for the microservices architecture development environment! This repository includes a docker-compose.yml file designed to spin up all necessary services for local development.\nüöÄ Overview This Docker Compose setup orchestrates multiple services that together form a microservices-based application ecosystem. It is only intended for development purposes and includes:\nNATS \u0026 NATS UI: Messaging system with JetStream enabled for event streaming and an admin UI for monitoring. MongoDB: Document-oriented NoSQL database for data storage. MinIO: High-performance, S3-compatible object storage. Various Application Services: Gateway: API gateway routing requests. User Service: Manages user data and authentication. Angebot Service: Business-specific service for offers management. Media Service: Handles media file uploads and processing. Frontend \u0026 NGINX: Web frontend served through NGINX with HTTPS support. üì¶ Services Included Service Description Ports nats Messaging server with JetStream enabled 4222, 8222 nats-ui NATS monitoring UI 31311 mongo MongoDB database 27017 minio Object storage (S3 compatible) 9000 (API), 9001 (Console) gateway API Gateway 8081 user-service User management 8082 angebot-service Offers management 8084 media-service Media handling 8083 frontend Web frontend 8080 nginx Reverse proxy \u0026 HTTPS termination 80, 443 ‚öôÔ∏è How to Run Make sure you have Docker and Docker Compose installed.\nClone the repository:\ngit clone https://github.com/Konzepte-moderner-Softwareentwicklung/Backend.git cd Backend ","-overview#üöÄ Overview":"","-services-included#üì¶ Services Included":"","microservices-architecture--docker-compose-setup#Microservices Architecture ‚Äî Docker Compose Setup!":""},"title":"Docs"},"/Docu/docs/chat-service/":{"data":{"-abh√§ngigkeiten#üß© Abh√§ngigkeiten":"","-api-endpunkte#üìö API-Endpunkte":"","-authentifizierung#üîê Authentifizierung":"","-chatcontroller--dokumentation#üì¶ ChatController ‚Äì Dokumentation":"","-erweiterbarkeit#üîÑ Erweiterbarkeit":" classDiagram\rdirection TB\rclass ChatController {\r- service: Service\r- AuthMiddleware: AuthMiddleware\r+HandleGetChats(w http.ResponseWriter, r *http.Request)\r+CreateChat(w http.ResponseWriter, r *http.Request)\r+HandleGetChat(w http.ResponseWriter, r *http.Request)\r+HandleSendMessage(w http.ResponseWriter, r *http.Request)\r+setupRoutes()\r}\rclass Service {\r+GetChats(userId uuid.UUID) []Chat\r+CreateChat(userIds ...uuid.UUID) uuid.UUID\r+GetChat(chatId, userId uuid.UUID) []Message\r+SendMessage(userId, chatId uuid.UUID, content string) error\r}\rclass AuthMiddleware {\r+EnsureJWT(handler http.HandlerFunc) http.HandlerFunc\r}\rclass Server {\r+WithHandlerFunc(path string, handler http.HandlerFunc, method string)\r+Error(w http.ResponseWriter, message string, statusCode int)\r+GetLogger() Logger\r}\rChatController --\u003e Service\rChatController --\u003e AuthMiddleware\rChatController --\u003e Server\rService --\u003e Repo\rclass Repo {\r\u003c\u003cinterface\u003e\u003e\r} üì¶ ChatController ‚Äì Dokumentationüß≠ √úbersicht Der ChatController ist ein HTTP-Controller f√ºr den Chat-Service der Anwendung. Er stellt verschiedene REST-Endpoints zur Verf√ºgung, um Chats zu erstellen, abzurufen und Nachrichten zu versenden. Der Controller verwendet JWT-Authentifizierung und basiert auf Gorilla Mux f√ºr das Routing.\nüß© Abh√§ngigkeiten github.com/google/uuid ‚Äì zur Arbeit mit UUIDs.\ngithub.com/gorilla/mux ‚Äì HTTP-Router.\nBenutzerdefinierte Module:\nservice ‚Äì enth√§lt die Gesch√§ftslogik f√ºr Chats. repo ‚Äì Schnittstelle zur Datenbank. auth ‚Äì JWT-Authentifizierung. server ‚Äì generische Server-Initialisierung und Hilfsmethoden. üîê Authentifizierung Alle Endpunkte sind durch ein JWT gesch√ºtzt. Der Authentifizierungs-Middleware EnsureJWT() √ºberpr√ºft den Token und stellt sicher, dass der Request g√ºltig ist. Die UserId wird aus dem HTTP-Header UserIdHeader gelesen, der durch die Middleware gesetzt wird.\nüìö API-Endpunkte GET /chat Beschreibung: Gibt alle Chats des authentifizierten Nutzers zur√ºck. Header: Authorization: Bearer \u003cJWT\u003e Antwort: JSON-Liste von repo.Chat Objekten.\nPOST /chat Beschreibung: Erstellt einen neuen Chat mit den angegebenen Benutzer-IDs (inklusive sich selbst). Body:\n{ \"userIds\": [\"\u003cuuid1\u003e\", \"\u003cuuid2\u003e\", ...] } Antwort: ID des neu erstellten Chats als JSON-String.\nGET /chat/{chatId} Beschreibung: Gibt alle Nachrichten f√ºr einen bestimmten Chat zur√ºck. Path-Parameter: chatId (UUID) Antwort: JSON-Liste von repo.Message Objekten.\nPOST /chat/{chatId}/messages Beschreibung: Sendet eine Nachricht in einen bestimmten Chat. Path-Parameter: chatId (UUID) Body:\n{ \"content\": \"Hallo Welt!\" } Antwort: HTTP 201 Created, keine Body-Antwort.\n‚öôÔ∏è Funktionsweise im Detail Initialisierung: Die Funktion New() erstellt eine neue ChatController-Instanz, registriert alle Routen und initialisiert den Service. Routing: Wird durch setupRoutes() konfiguriert. Fehlerbehandlung: Einheitlich √ºber die Methode Error(w, message, code) aus der eingebetteten Server-Struktur. Logging: Der Controller nutzt GetLogger().Debug() zur Protokollierung von Nachrichten. üß™ Fehlerbehandlung Die API gibt im Fehlerfall strukturierte JSON-Objekte vom Typ ErrorResponse zur√ºck:\n{ \"message\": \"Fehlermeldung\" } HTTP-Statuscodes:\n400 Bad Request: Ung√ºltige UUIDs, fehlerhaftes JSON etc. 500 Internal Server Error: Fehler aus der Gesch√§ftslogik oder Datenbank. üîÑ Erweiterbarkeit Der Controller ist modular aufgebaut:\nNeue Endpunkte k√∂nnen leicht durch weitere Methoden und WithHandlerFunc-Registrierungen erg√§nzt werden. Service-Schicht kapselt die Gesch√§ftslogik und ist leicht austauschbar/testbar. Durch Middleware flexibel erweiterbar (z.‚ÄØB. f√ºr Rate-Limiting, Logging, etc.). ","-fehlerbehandlung#üß™ Fehlerbehandlung":"","-funktionsweise-im-detail#‚öôÔ∏è Funktionsweise im Detail":"","-√ºbersicht#üß≠ √úbersicht":""},"title":"Chat Service"},"/Docu/docs/gateway/":{"data":{"beispiel-client-code-javascript#Beispiel Client-Code (JavaScript)":" classDiagram\rdirection TB\rclass Service {\r+*server.Server\r+*auth.AuthMiddleware\r+*jwt.Decoder\r+NR *natsreciver.Receiver\r+WSHandler(w http.ResponseWriter, r *http.Request)\r+HandleChatWS(w http.ResponseWriter, r *http.Request)\r+HandleTracking(w http.ResponseWriter, r *http.Request)\r+HealthCheck(w http.ResponseWriter, r *http.Request)\r+LogNats()\r+Close() error\r}\rclass server.Server {\r+GetLogger() zerolog.Logger\r+WithHandlerFunc(path string, handler http.HandlerFunc, methods...)\r+Error(w http.ResponseWriter, message string, code int)\r}\rclass auth.AuthMiddleware {\r+EnsureJWT(handler http.HandlerFunc) http.HandlerFunc\r}\rclass jwt.Decoder {\r+DecodeUUID(token string) (uuid.UUID, error)\r}\rclass natsreciver.Receiver {\r+Subscribe(subject string, handler func(*nats.Msg)) (Subscription, error)\r+Publish(subject string, data []byte) error\r+Close() error\r}\rclass zerolog.Logger {\r+Info()\r+Debug()\r+Err(error)\r}\rclass http.Request\rclass http.ResponseWriter\rclass websocket.Conn\rclass TrackingRequest {\r+Location repoangebot.Location\r}\rService --\u003e server.Server\rService --\u003e auth.AuthMiddleware\rService --\u003e jwt.Decoder\rService --\u003e natsreciver.Receiver\rService --\u003e websocket.Conn : Uses in WSHandler\rService --\u003e zerolog.Logger : Uses for logging\rService --\u003e TrackingRequest : Uses in HandleTracking\rService --\u003e http.ResponseWriter : Handles HTTP\rService --\u003e http.Request : Handles HTTP Gateway Service - DokumentationDer Gateway-Service ist ein zentraler HTTP-Proxy, der eingehende Anfragen basierend auf dem URL-Pfad an die jeweils zust√§ndigen Microservices weiterleitet.\nZweck Zentrale Anlaufstelle f√ºr Clients Weiterleitung von HTTP-Anfragen an Microservices Einfaches Routing basierend auf URL-Pr√§fixen Einheitliche Schnittstelle f√ºr mehrere Backend-Services Routing-Regeln URL-Pfad-Pr√§fix Zielservice Beschreibung api/user/* User-Service (z.B. http://userservice:8080) Benutzerverwaltung api/angebot/* Angebot-Service (z.B. http://angebotservice:8080) Angebotsverwaltung api/media/* Media-Service (z.B. http://mediaservice:8080) Medienverwaltung / (andere) Frontend oder 404-Fehler Standardseite oder Fehlerseite Nutzung als Client Clients senden alle Anfragen an das Gateway (z.B. https://localhost/api). Das Gateway sorgt automatisch daf√ºr, dass die Anfragen beim richtigen Service landen.\nBeispiel-Endpunkte (√ºber Gateway) HTTP Methode Pfad Zweck GET api/user/ Liste aller Benutzer abrufen POST api/user/ Neuen Benutzer anlegen PUT api/user/{id} Benutzer aktualisieren DELETE api/user/{id} Benutzer l√∂schen GET api/angebot/ Angebote abrufen GET api/media/{id} Mediendatei abrufen GET / Frontend oder Startseite Vorteile Vereinfachte Client-Integration: Ein einziger Endpunkt f√ºr alle Services Flexibles Routing: Einfaches Hinzuf√ºgen neuer Services und Pfade Zentrale Sicherheitskontrolle: Authentifizierung, Logging oder Rate-Limiting k√∂nnen hier zentral implementiert werden Entkopplung der Clients von den Backend-Services Beispiel Client-Code (JavaScript) const BASE_URL = \"https://localhost\"; // Benutzerliste abrufen async function fetchUsers() { const response = await fetch(`${BASE_URL}/users/`); if (!response.ok) throw new Error(\"Fehler beim Abrufen der Benutzer\"); return response.json(); } // Benutzer erstellen async function createUser(userData) { const response = await fetch(`${BASE_URL}/users/`, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(userData), }); if (!response.ok) throw new Error(\"Fehler beim Erstellen des Benutzers\"); return response.json(); } // Angebot abrufen async function fetchAngebote() { const response = await fetch(`${BASE_URL}/angebote/`); if (!response.ok) throw new Error(\"Fehler beim Abrufen der Angebote\"); return response.json(); } ","beispiel-endpunkte-√ºber-gateway#Beispiel-Endpunkte (√ºber Gateway)":"","gateway-service---dokumentation#Gateway Service - Dokumentation":"","nutzung-als-client#Nutzung als Client":"","routing-regeln#Routing-Regeln":"","vorteile#Vorteile":"","zweck#Zweck":""},"title":"Gateway"},"/Docu/docs/login/":{"data":{"dokumentation-zum-login-im-usercontroller#Dokumentation zum Login im \u003ccode\u003eUserController\u003c/code\u003e":"","endpunkte-und-funktionen#Endpunkte und Funktionen":"","wichtige-details#Wichtige Details":"Dokumentation zum Login im UserController√úbersicht Der UserController bietet mehrere Endpunkte zur Authentifizierung von Benutzern, sowohl √ºber klassische E-Mail/Passwort-Logins als auch √ºber WebAuthn (Passkey)-basierte Authentifizierung. Das Ziel ist es, den Benutzer sicher zu authentifizieren und bei Erfolg ein JWT-Token zur√ºckzugeben, das f√ºr 24 Stunden g√ºltig ist.\nEndpunkte und Funktionen 1. Klassischer Login: /users/login (POST) Funktion: GetLoginToken\nBeschreibung: Authentifiziert einen Benutzer anhand von E-Mail und Passwort. Bei erfolgreicher Authentifizierung wird ein JWT-Token generiert, das 24 Stunden g√ºltig ist.\nRequest Body (JSON):\n{ \"email\": \"string\", \"password\": \"string\" } Ablauf:\nE-Mail und Passwort werden aus dem JSON-Request ausgelesen. Benutzer wird anhand der E-Mail gesucht. Passwort wird mit dem gespeicherten Hash verglichen (√ºber hasher.VerifyPassword). Bei Erfolg wird ein JWT-Token erzeugt (EncodeUUID) und als JSON zur√ºckgegeben. Bei Fehlern wird ein entsprechender HTTP-Statuscode mit Fehlermeldung zur√ºckgegeben. Antwort (bei Erfolg):\n{ \"token\": \"JWT-Token\" } Fehler:\n400: Fehler beim Lesen der Anfrage 401: Falsches Passwort 500: Nutzer nicht gefunden oder Fehler bei Token-Generierung 2. WebAuthn Login WebAuthn-Login erfolgt in zwei Schritten: Optionen abrufen und Login abschlie√üen.\na) Begin WebAuthn Login: /users/webauthn/login/options (GET) Funktion: beginLogin\nBeschreibung: Startet den WebAuthn-Login-Prozess, indem Login-Optionen generiert werden.\nQuery Parameter:\nemail: E-Mail-Adresse des Benutzers Ablauf:\nValidiert die E-Mail-Adresse. Benutzer wird anhand der E-Mail gesucht. Login-Optionen und Session-Daten werden erzeugt (service.webauth.BeginLogin). Session-Daten werden im Benutzerobjekt gespeichert. Login-Optionen werden als JSON zur√ºckgegeben. Antwort (bei Erfolg): JSON mit WebAuthn-CredentialAssertion.\nFehler:\n400: Ung√ºltige E-Mail-Adresse 404: Benutzer nicht gefunden 500: Interner Serverfehler b) Finish WebAuthn Login: /users/webauthn/login (POST) Funktion: finishLogin\nBeschreibung: Verifiziert die WebAuthn-Anmeldung und gibt bei Erfolg ein JWT-Token zur√ºck.\nQuery Parameter:\nemail: E-Mail-Adresse des Benutzers Ablauf:\nValidiert die E-Mail-Adresse. Benutzer wird anhand der E-Mail gesucht. WebAuthn-Login wird mit Session-Daten √ºberpr√ºft (service.webauth.FinishLogin). Bei Erfolg wird ein JWT-Token f√ºr 24 Stunden generiert und zur√ºckgegeben. Antwort (bei Erfolg):\n{ \"token\": \"JWT-Token\" } Fehler:\n400: Ung√ºltige E-Mail-Adresse 401: Authentifizierung fehlgeschlagen 404: Benutzer nicht gefunden 500: Interner Serverfehler Wichtige Details JWT-Token: Ein JWT wird mit der Benutzer-ID als Payload erzeugt, g√ºltig f√ºr 24 Stunden.\nSession-Daten bei WebAuthn:\nBeginLogin und FinishLogin verwenden sessionData, die tempor√§r im User-Objekt gespeichert werden. Diese Session-Daten sind notwendig zur Validierung des WebAuthn-Ablaufs. Fehlerbehandlung: Alle Fehler f√ºhren zu einer aussagekr√§ftigen HTTP-Antwort mit Statuscode und Fehlermeldung.","√ºbersicht#√úbersicht":""},"title":"Login"},"/Docu/docs/media-service/":{"data":{"beispiel-request-upload-bild#Beispiel-Request Upload Bild":"","endpunkte#Endpunkte":"","fehlerbehandlung#Fehlerbehandlung":" classDiagram\rclass MediaController {\r-mediaservice *MediaService\r-Server *Server\r+New(svc *MediaService) MediaController\r+setupRoutes()\r+handleIndex(w http.ResponseWriter, r *http.Request)\r+UploadPicture(w http.ResponseWriter, r *http.Request)\r+DownloadPicture(w http.ResponseWriter, r *http.Request)\r+GetCompoundLinks(w http.ResponseWriter, r *http.Request)\r+UploadToCompoundLinks(w http.ResponseWriter, r *http.Request)\r}\rclass MediaService {\r+UploadPicture(ctx context.Context, user string, contentType string, img []byte) (string, error)\r+GetPicture(ctx context.Context, name string) ([]byte, error)\r+GetMultiPicture(ctx context.Context, user uuid.UUID) ([]string, error)\r+UploadPictureToMulti(ctx context.Context, user string, id string, contentType string, img []byte) error\r}\rclass Server {\r+NewServer() *Server\r+WithHandlerFunc(path string, handler func(http.ResponseWriter, *http.Request), method string)\r+Error(w http.ResponseWriter, message string, code int)\r+GetLogger() Logger\r}\rclass Logger {\r+Err(err error)\r}\rMediaController --\u003e MediaService : uses\rMediaController --\u003e Server : embeds\rServer --\u003e Logger : uses MediaService ControllerDer MediaService Controller stellt HTTP-Endpunkte bereit, um Bilder und Medieninhalte zu verwalten. Dies umfasst den Upload, Download und das Verwalten mehrerer Bild-Links f√ºr Benutzer oder Angebote.\n√úbersicht Der Controller ist Teil des MediaService und bindet sich an die Business-Logik (service.MediaService) sowie den HTTP-Server (server.Server). Er bietet folgende Funktionalit√§ten:\nUpload einzelner Bilder (z.B. Profilbilder, Banner) Download einzelner Bilder Verwalten von ‚ÄúCompound Links‚Äù, d.h. mehreren Bildern, die einem Nutzer oder Objekt zugeordnet sind (z.B. mehrere Bilder zu einem Angebot) Healthcheck Endpunkte GET /media/image Beschreibung: Health-Check Endpoint, gibt ‚ÄûHello World‚Äú zur√ºck Antwort: 200 OK, Text ‚ÄûHello World‚Äú POST /media/image Beschreibung: Upload eines einzelnen Bildes f√ºr den authentifizierten Benutzer\nHeaders:\nAuthorization (JWT Token, Pflicht) Content-Type (z.B. image/jpeg, Pflicht) UserId (User-ID im Header) Body: Bilddaten (rohe Bytes)\nAntwort:\n200 OK mit JSON { \"name\": \"\u003cBildname\u003e\", \"success\": true } Fehlercodes: 400 (Bad Request), 500 (Serverfehler) GET /media/image/{id} Beschreibung: Download eines Bildes anhand des Namens/IDs\nParameter:\nid (Pfadparameter, Bildname) Antwort:\n200 OK mit Bilddaten (image/jpeg) Fehlercodes: 400, 500 GET /media/multi/{id} Beschreibung: Gibt eine Liste von URLs zur√ºck, die zu mehreren Bildern (Compound Links) eines Nutzers geh√∂ren\nParameter:\nid (Pfadparameter, User UUID) Antwort:\n200 OK mit JSON-Array von Bild-URLs Fehlercodes: 400, 500 POST /media/multi/{id} Beschreibung: Upload eines Bildes, das mit Compound Links f√ºr einen bestimmten User/Offer verkn√ºpft wird\nHeaders:\nAuthorization (JWT Token) Content-Type (z.B. image/jpeg) UserId (User-ID im Header) Parameter:\nid (Pfadparameter, Compound Link ID) Body: Bilddaten (rohe Bytes)\nAntwort: 200 OK bei Erfolg\nFehlercodes: 400, 500\nImplementierungsdetails Nutzt github.com/gorilla/mux f√ºr Routing. Setzt voraus, dass der User √ºber den UserIdHeader im HTTP Header identifiziert wird. Nutzt den MediaService (service.MediaService) f√ºr alle Business-Logik Operationen (Upload, Download, Verwaltung von Compound Links). Fehler werden als JSON mit { \"message\": \"Fehlermeldung\" } zur√ºckgegeben. Unterst√ºtzt Multipart-Bild-Uploads nicht (rohe Bytes im Request Body). Beispiel-Request Upload Bild curl -X POST \"http://localhost:8080/media/image\" \\ -H \"Authorization: Bearer \u003cjwt-token\u003e\" \\ -H \"UserId: \u003cuser-uuid\u003e\" \\ -H \"Content-Type: image/jpeg\" \\ --data-binary \"@meinbild.jpg\" Fehlerbehandlung Der Controller gibt bei Fehlern aussagekr√§ftige HTTP-Statuscodes zur√ºck:\nStatuscode Bedeutung 400 Ung√ºltige Anfrage (z.B. fehlende Parameter, fehlerhafte UUID) 500 Interner Serverfehler (z.B. Probleme beim Zugriff auf Medienservice) ","implementierungsdetails#Implementierungsdetails":"","mediaservice-controller#MediaService Controller":"","√ºbersicht#√úbersicht":""},"title":"Media Service"},"/Docu/docs/offer-service/":{"data":{"-abh√§ngigkeiten#üìö Abh√§ngigkeiten":" classDiagram\r%% Controller\rclass OfferController {\r- Server *server.Server\r- Client *msclient.Client\r- service service.Service\r- AuthMiddleware *auth.AuthMiddleware\r- Conn *nats.Conn\r+ PayOffer()\r+ OccupyOffer()\r+ handleCreateOffer()\r+ handleGetOffer()\r+ handleGetOfferByFilter()\r+ handlePostRating()\r}\r%% Services\rclass service.Service {\r+ CreateOffer(offer, imageURL)\r+ GetOffer(uuid)\r+ GetOffersByFilter(filter)\r+ OccupieOffer(id, userId, space)\r+ PayOffer(id, userId)\r}\rclass repoangebot.Offer {\r- uuid ID\r- string Title\r- string Description\r- Location Location\r- float64 Price\r- float64 Size\r- Time AvailableFrom\r- uuid Creator\r}\rclass repoangebot.Space {\r- float Width\r- float Height\r- float Depth\r}\rclass repoangebot.Filter {\r- float MinPrice\r- float MaxPrice\r- float Latitude\r- float Longitude\r- float Radius\r}\rclass ratingservice.Rating {\r- int Score\r- string Comment\r}\r%% Abh√§ngigkeiten \u0026 Beziehungen\rOfferController --\u003e service.Service\rOfferController --\u003e repoangebot.Offer\rOfferController --\u003e repoangebot.Space\rOfferController --\u003e repoangebot.Filter\rOfferController --\u003e ratingservice.Rating\rOfferController --\u003e msclient.Client\rOfferController --\u003e auth.AuthMiddleware\rOfferController --\u003e nats.Conn üì¶ AngebotserviceDer angebotservice stellt REST-HTTP-Endpunkte zur Verwaltung von Angeboten bereit. Dazu geh√∂ren das Erstellen, Abrufen, Buchen, Bezahlen und Bewerten von Angeboten. Die Authentifizierung erfolgt per JWT, und die Bewertung wird asynchron √ºber NATS verarbeitet.\nüß∞ Features üîê Authentifizierte Angebots-Erstellung üîé Filterbare Angebotssuche üí¨ Bewertungen √ºber NATS Messaging üí≥ Angebotsbuchung \u0026 Bezahlung üñºÔ∏è Bild-URL-Generierung √ºber Medienservice ‚úÖ Swagger-kompatible API-Dokumentation üöÄ Quickstart Voraussetzungen Go 1.20+ NATS Server (erreichbar √ºber Umgebungsvariable NATS_URL) Auth-Secret (f√ºr JWT-Middleware) Beispiel: Initialisierung svc := service.NewOfferService(repo, mediaClient) secret := []byte(\"dein_geheimes_jwt_secret\") controller := angebotservice.New(svc, secret) http.ListenAndServe(\":8080\", controller.Router) üîÅ HTTP-Endpunkte Methode Pfad Beschreibung Authentifizierung POST /angebot/filter Angebote nach Filter abrufen ‚ùå POST /angebot Neues Angebot erstellen ‚úÖ GET /angebot/{id} Angebot nach ID abrufen ‚ùå POST /angebot/{id}/occupy Angebot buchen ‚úÖ POST /angebot/{id}/pay Angebot bezahlen ‚úÖ POST /angebot/{id}/rating Angebot bewerten (via NATS) ‚úÖ üîê Authentifizierung JWT wird √ºber den HTTP-Header Authorization: Bearer \u003ctoken\u003e mitgesendet. Der Token muss die UserId enthalten, welche vom auth.AuthMiddleware ausgelesen und als Header UserId weitergereicht wird. üßæ Beispieldatenstrukturen üéØ Angebotsstruktur (repoangebot.Offer) { \"title\": \"Tiefgaragenstellplatz\", \"description\": \"Mit direktem Zugang zum Aufzug.\", \"location\": { \"latitude\": 48.137, \"longitude\": 11.575 }, \"price\": 50, \"size\": 12, \"availableFrom\": \"2025-07-01\" } üì• Bewertung (ratingservice.Rating) { \"score\": 5, \"comment\": \"Super Angebot!\" } üí¨ NATS Messaging Bewertungen werden nicht synchron in die Datenbank geschrieben. Stattdessen werden sie √ºber NATS ver√∂ffentlicht: c.Publish(\"rating.{userID}\", body) üêû Fehlerbehandlung Antworten im Fehlerfall sind konsistent aufgebaut:\n{ \"message\": \"Fehlerbeschreibung\" } Beispiele f√ºr Statuscodes:\n400 Bad Request ‚Äì z.‚ÄØB. bei fehlerhafter UUID 401 Unauthorized ‚Äì fehlende oder ung√ºltige JWT 500 Internal Server Error ‚Äì unerwartete Fehler üìö Abh√§ngigkeiten Gorilla Mux ‚Äì Routing\nGoogle UUID\nNATS Go Client\nEigene Module:\nauth server ratingservice mediaservice/msclient angebotservice/service/repo_angebot ","-angebotservice#üì¶ Angebotservice":"","-authentifizierung#üîê Authentifizierung":"","-beispieldatenstrukturen#üßæ Beispieldatenstrukturen":"","-features#üß∞ Features":"","-fehlerbehandlung#üêû Fehlerbehandlung":"","-http-endpunkte#üîÅ HTTP-Endpunkte":"","-nats-messaging#üí¨ NATS Messaging":"","-quickstart#üöÄ Quickstart":""},"title":"Angebot Service"},"/Docu/docs/rating-service/":{"data":{"endpunkt-get-ratingsuser#Endpunkt: GET /ratings/{user}":" classDiagram\rclass Service {\r+setupRoutes()\r+HandleGetRatings(w http.ResponseWriter, r *http.Request)\r+GetRatings(userID uuid.UUID) ([]Rating, error)\r+Error(w http.ResponseWriter, message string, statusCode int)\r}\rclass ErrorResponse {\r+Message string\r}\rclass Rating {\r+ID uuid.UUID\r+UserID uuid.UUID\r+Score int\r+Comment string\r}\rService \"1\" --\u003e \"*\" Rating : returns Rating Service APIDer Rating Service stellt eine HTTP-API zur Verf√ºgung, um Bewertungen (Ratings) f√ºr Benutzer abzurufen.\nEndpunkt: GET /ratings/{user} Beschreibung Ruft alle Bewertungen f√ºr einen bestimmten Benutzer ab.\nPfadparameter Name Typ Pflicht Beschreibung user string ja UUID des Benutzers, f√ºr den die Bewertungen abgefragt werden Anfrage Methode: GET\nURL: /ratings/{user}\nHeader:\nAccept: application/json Antwort Erfolgsfall (200 OK): Ein JSON-Array mit den Bewertungen des angegebenen Benutzers. Beispiel:\n[ { \"id\": \"uuid\", \"userID\": \"uuid\", \"score\": 5, \"comment\": \"Great service!\" }, ... ] Fehlerf√§lle:\n400 Bad Request: Wenn die √ºbergebene Benutzer-ID keine g√ºltige UUID ist. Beispiel:\n{ \"message\": \"invalid UUID format\" } 500 Internal Server Error: Wenn ein unerwarteter Fehler beim Abrufen der Bewertungen auftritt. Beispiel:\n{ \"message\": \"database error\" } Hinweise Die Benutzer-ID muss im UUID-Format vorliegen. Die Methode GetRatings(userID uuid.UUID) wird verwendet, um die Bewertungen aus der Datenquelle zu holen. Die Response enth√§lt den Content-Type Header application/json. ","rating-service-api#Rating Service API":""},"title":"Rating Service"},"/Docu/docs/tracking-service/":{"data":{"abh√§ngigkeiten#Abh√§ngigkeiten":"","beispiel-f√ºr-tracking-daten-gatewaytrackingrequest#Beispiel f√ºr Tracking-Daten (gateway.TrackingRequest)":"","fehlerbehandlung#Fehlerbehandlung":" classDiagram\rclass TrackingService {\r- queue *nats.Conn\r- logger zerolog.Logger\r- offerClient *offerclient.OfferClient\r- mongoClient TrackingRepo\r+ NewTrackingService(natsURL string, offerURL string, mongoURL string) TrackingService\r+ WithLogger(logger zerolog.Logger) TrackingService\r+ Start()\r}\rclass TrackingRepo {\r\u003c\u003cinterface\u003e\u003e\r+ SaveTracking(tracking Tracking) error\r}\rclass mongoTrackingRepo {\r- trackingCollection *mongo.Collection\r+ SaveTracking(tracking Tracking) error\r}\rTrackingRepo \u003c|.. mongoTrackingRepo\rclass Location {\r+ Latitude float64\r+ Longitude float64\r}\rTrackingService --\u003e TrackingRepo : uses\rTracking Service Dokumentation√úberblick Der Tracking Service ist verantwortlich f√ºr das Erfassen, Speichern und Weiterleiten von Tracking-Daten der Benutzer. Er empf√§ngt Tracking-Informationen √ºber eine NATS-Messaging-Queue, speichert diese in einer MongoDB-Datenbank und ver√∂ffentlicht Tracking-Daten an verbundene Nutzer basierend auf verf√ºgbaren Angeboten.\nKomponenten 1. Repository (package repo) mongoTrackingRepo Verwaltet die MongoDB-Verbindung und die Sammlung (tracking). Verbindet sich mit der MongoDB √ºber die URI beim Erstellen (NewMongoTrackingRepo). Speichert Tracking-Daten mit SaveTracking(tracking Tracking) error in die MongoDB. Tracking (Struct) Repr√§sentiert ein Tracking-Dokument, das gespeichert wird.\nFelder:\nUserID (UUID): Die ID des Benutzers, zu dem das Tracking geh√∂rt. Tracking (gateway.TrackingRequest): Das eigentliche Tracking-Objekt, das Standort- und weitere Tracking-Daten enth√§lt. TrackingRepo (Interface) Definiert die Methode SaveTracking(Tracking) error, um Tracking-Daten zu speichern. 2. TrackingService (package trackingservice) Struktur queue (*nats.Conn): Verbindung zur NATS-Messaging-Queue. logger (zerolog.Logger): Logger f√ºr Ereignisse und Fehler. offerClient (*offerclient.OfferClient): Client zum Abrufen von Angeboten. mongoClient (repo.TrackingRepo): Repository zum Speichern der Tracking-Daten in MongoDB. Konstruktor func NewTrackingService(natsURL string, offerURL string, mongoURL string) *TrackingService Initialisiert alle notwendigen Komponenten (NATS-Verbindung, Logger, OfferClient, MongoDB Repository). Verbindet sich mit NATS, Offer-Service und MongoDB. Methoden WithLogger(logger zerolog.Logger) *TrackingService: Erm√∂glicht das Setzen eines benutzerdefinierten Loggers. Start(): Startet den Service und abonniert Tracking-Nachrichten auf dem NATS-Subject tracking.user.*. Funktionsweise (Start Methode) Abonnement auf NATS Topic tracking.user.*, wobei * die UserID ist.\nEmpfangene Nachrichten werden verarbeitet:\nExtrahieren der UserID aus dem Topic. Abrufen der relevanten Angebote f√ºr diesen User √ºber den offerClient. Wenn keine Angebote gefunden wurden, wird die Nachricht verworfen. Deserialisierung der Tracking-Daten (TrackingRequest). Speicherung der Tracking-Daten in MongoDB. Weiterleitung der Tracking-Daten an alle Benutzer, die im OccupiedSpace des Angebots enthalten sind. Fehler beim Parsen, Abrufen, Speichern oder Ver√∂ffentlichen werden geloggt.\nAbh√§ngigkeiten MongoDB (Datenbank f√ºr Tracking-Daten). NATS (Messaging-System f√ºr Event-basierte Kommunikation). offerclient (Client zur Kommunikation mit dem Angebot-Service). zerolog (Logging-Framework). UUID (Identifikation von Benutzern). gateway.TrackingRequest (Datenmodell f√ºr Tracking-Daten). Beispiel f√ºr Tracking-Daten (gateway.TrackingRequest) { \"location\": { \"latitude\": 52.5200, \"longitude\": 13.4050 }, \"timestamp\": \"2025-06-27T12:00:00Z\" } Fehlerbehandlung Verbindungsfehler zu NATS oder MongoDB f√ºhren zu einem panic bei Initialisierung. Laufzeitfehler beim Verarbeiten von Nachrichten werden geloggt, der Service l√§uft jedoch weiter. Keine Angebote f√ºr einen User f√ºhren zu einer Info-Logmeldung. ","funktionsweise-start-methode#Funktionsweise (\u003ccode\u003eStart\u003c/code\u003e Methode)":"","komponenten#Komponenten":"","tracking-service-dokumentation#Tracking Service Dokumentation":"","√ºberblick#√úberblick":""},"title":"Tracking Service"},"/Docu/docs/user-service/":{"data":{"api-endpunkte-und-funktionalit√§ten#API-Endpunkte und Funktionalit√§ten":"","beispiel-f√ºr-eine-typische-benutzeranfrage#Beispiel f√ºr eine typische Benutzeranfrage":" classDiagram\rclass UserController {\r+Server\r+AuthMiddleware\r+Encoder\r-service: UserService\r-ratingClient: RatingClient\r+GetSelfId(w http.ResponseWriter, r *http.Request)\r+HandleGetRating(w http.ResponseWriter, r *http.Request)\r+beginRegistration(w http.ResponseWriter, r *http.Request)\r+finishRegistration(w http.ResponseWriter, r *http.Request)\r+beginLogin(w http.ResponseWriter, r *http.Request)\r+finishLogin(w http.ResponseWriter, r *http.Request)\r+GetUsers(w http.ResponseWriter, r *http.Request)\r+GetUserByEmail(w http.ResponseWriter, r *http.Request)\r+CreateUser(w http.ResponseWriter, r *http.Request)\r+GetUser(w http.ResponseWriter, r *http.Request)\r+UpdateUser(w http.ResponseWriter, r *http.Request)\r+DeleteUser(w http.ResponseWriter, r *http.Request)\r+GetLoginToken(w http.ResponseWriter, r *http.Request)\r}\rclass UserService {\r+GetUserByID(uuid.UUID) User\r+GetUsers() []User\r+CreateUser(User) error\r+UpdateUser(uuid.UUID, User) error\r+DeleteUser(uuid.UUID) error\r+repo: UserRepository\r+webauth: WebAuthService\r}\rclass RatingClient {\r+GetRatingsByUserID(uuid.UUID) []Rating\r}\rclass UserRepository {\r+GetUserByEmail(string) User\r+GetUserByID(uuid.UUID) User\r+UpdateUser(User) error\r}\rclass WebAuthService {\r+BeginRegistration(User) (CredentialCreation, SessionData, error)\r+FinishRegistration(User, SessionData, *http.Request) (Credential, error)\r+BeginLogin(User) (CredentialAssertion, SessionData, error)\r+FinishLogin(User, SessionData, *http.Request) (bool, error)\r}\rclass User {\r+ID: uuid.UUID\r+Email: string\r+Password: string\r+SessionData: SessionData\r+AddCredential(Credential)\r}\rUserController --\u003e UserService : uses\rUserController --\u003e RatingClient : uses\rUserService --\u003e UserRepository : uses\rUserService --\u003e WebAuthService : uses\rUserRepository ..\u003e User : manages\rWebAuthService ..\u003e User : operates on Dokumentation zum Package userservice√úberblick Das Package userservice implementiert einen HTTP-Controller zur Verwaltung von Benutzerkonten in einem Backend-System. Es bietet REST-API-Endpunkte f√ºr Benutzeroperationen wie Erstellen, Lesen, Aktualisieren, L√∂schen (CRUD), Authentifizierung via JWT und WebAuthn sowie Integration mit einem externen Bewertungssystem.\nHauptkomponenten UserController UserController ist die zentrale Komponente, die HTTP-Anfragen entgegennimmt, verarbeitet und die Benutzerlogik koordiniert.\nFelder:\nServer ‚Äî HTTP-Server-Basis. AuthMiddleware ‚Äî Middleware zur JWT-Authentifizierung. Encoder ‚Äî JWT-Encoder zum Erstellen von Tokens. service ‚Äî Business-Logik-Service f√ºr Benutzeroperationen. ratingClient ‚Äî Client f√ºr den Zugriff auf externe Benutzerratings. Konstruktor:\nNew(svc *UserService, secret []byte) *UserController\nInitialisiert den Controller, l√§dt Umgebungsvariablen (z.B. RATING_SERVICE_URL), richtet Middleware ein und konfiguriert die API-Routen. API-Endpunkte und Funktionalit√§ten Benutzer-Endpoints GET /self\nGibt die User-ID des aktuell authentifizierten Benutzers zur√ºck. Authentifizierung via JWT erforderlich. GET /users\nLiefert eine Liste aller Benutzer. GET /users/{id}\nLiefert Details eines Benutzers anhand der UUID (Passwort wird nicht zur√ºckgegeben). GET /users/email?email=...\nLiefert einen Benutzer anhand der E-Mail-Adresse. POST /users\nErstellt einen neuen Benutzer mit den √ºbergebenen JSON-Daten. PUT /users/{id}\nAktualisiert den Benutzer mit der angegebenen ID. Authentifizierung via JWT erforderlich. DELETE /users/{id}\nL√∂scht den Benutzer mit der angegebenen ID. Authentifizierung via JWT erforderlich. Authentifizierungsendpunkte POST /users/login\nAuthentifiziert einen Benutzer anhand von E-Mail und Passwort. Gibt bei Erfolg ein JWT zur√ºck, g√ºltig f√ºr 24 Stunden. WebAuthn Registrierung \u0026 Login\nGET /users/webauthn/register/options\nBeginnt die WebAuthn-Registrierung (liefert Registrierungsoptionen). Authentifizierung via JWT erforderlich. POST /users/webauthn/register\nSchlie√üt die WebAuthn-Registrierung ab. Authentifizierung via JWT erforderlich. GET /users/webauthn/login/options?email=...\nBeginnt die WebAuthn-Login-Prozedur (liefert Loginoptionen). POST /users/webauthn/login?email=...\nSchlie√üt den WebAuthn-Login ab und gibt ein JWT zur√ºck. Externe Bewertung GET /users/{id}/rating\nRuft Bewertungen des Benutzers vom externen Rating-Service ab. Fehlerbehandlung Fehler werden meist als JSON-Antwort mit einer ErrorResponse zur√ºckgegeben, die eine Fehlermeldung (Message) enth√§lt. Statuscodes wie 400 (Bad Request), 401 (Unauthorized), 404 (Not Found) und 500 (Internal Server Error) werden entsprechend gesetzt.\nMiddleware und CORS Der Controller setzt CORS-Header dynamisch basierend auf dem Origin der Anfrage. Zudem sch√ºtzt er kritische Endpunkte mit JWT-Authentifizierung mittels Middleware.\nBeispiel f√ºr eine typische Benutzeranfrage Ein Client sendet eine POST-Anfrage an /users/login mit E-Mail und Passwort. Der Controller validiert die Eingaben, √ºberpr√ºft das Passwort und generiert ein JWT. Dieses JWT wird vom Client gespeichert und f√ºr zuk√ºnftige autorisierte Anfragen im Authorization-Header mitgeschickt. Bei Zugriff auf gesch√ºtzte Endpunkte wird das Token validiert, und die angeforderte Operation ausgef√ºhrt. ","dokumentation-zum-package-userservice#Dokumentation zum Package \u003ccode\u003euserservice\u003c/code\u003e":"","fehlerbehandlung#Fehlerbehandlung":"","hauptkomponenten#Hauptkomponenten":"","middleware-und-cors#Middleware und CORS":"","√ºberblick#√úberblick":""},"title":"User Service"}}